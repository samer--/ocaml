xreify_sampler (collect 100 (sample_importance_map 1)) (reify test2) ();;
#use "test-p.ml";;
xreify_sampler (collect 100 (sample_importance_map 1)) (reify test2) ();;
IS.xreify_sampler (collect 100 (sample_importance_map 1)) (reify test2) ();;
IS.xreify_sampler (collect 100 (sample_importance_map 1)) (reify test2);;
IT.xreify_sampler (collect 10 (sample_importance_map 1)) (reify test2);;
IT.xreify_sampler (collect 10 (sample_importance_map 1)) (IT.reify test2);;
#use "test-p.ml";;
xreify_sampler (collect 100 (sample_importance_map 1)) (reify test2);;
let open IS in xreify_sampler (collect 100 (sample_importance_map 1)) (reify test2);;
let open IS in xreify_sampler (collect 100 (sample_importance_map 1)) (reify test2) ();;
let open IT in xreify_sampler (collect 100 (sample_importance_map 1)) (reify test2);;
let open IT in xreify_sampler (collect 2 (sample_importance_map 1)) (reify test2);;
let open IT in print (F.pair "," F.int (F.pair ":" F.rat int_list)) xreify_sampler (collect 2 (sample_importance_map 1)) (reify test2);;
let open IT in print (F.pair "," F.int (F.pair ":" F.rat int_list)) $ xreify_sampler (collect 2 (sample_importance_map 1)) (reify test2);;
let open IT in print (F.pair "," F.int (F.pair ":" F.rat int_list)) (xreify_sampler (collect 2 (sample_importance_map 1)) (reify test2));;
let open IT in print (F.pair "," F.int (F.list "," (F.pair ":" F.rat int_list))) (xreify_sampler (collect 2 (sample_importance_map 1)) (reify test2));;
print_string "hello";;
#use "test-p.ml";;
let open IT in print (F.pair "," F.int (F.list "," (F.pair ":" F.rat int_list))) (xreify_sampler (collect 2 (sample_importance_map 1)) (reify test2));;
#use "test-p.ml";;
let open IT in print (F.pair "," F.int (F.list "," (F.pair ":" F.rat int_list))) (xreify_sampler (collect 2 (sample_importance_map 1)) (reify test2));;
#use "test-p.ml";;
let open IT in print (F.pair "," F.int (F.list "," (F.pair ":" F.rat int_list))) (xreify_sampler (collect 2 (sample_importance_map 1)) (reify test2));;
let open IT in print (F.pair "," F.int (F.list "," (F.pair ":" F.rat int_list))) (xreify_sampler (collect 2 (map_sampler accum_simple sample_rejection)) (reify test2));;
let open IT in print (F.pair "," F.int (F.list "," (F.pair ":" F.rat int_list))) (xreify_sampler (collect 1 (map_sampler accum_simple sample_rejection)) (reify test2));;
let open IT in print (F.pair "," F.int (F.list ";" (F.pair "," F.rat int_list))) (xreify_sampler (collect 1 (map_sampler accum_simple sample_rejection)) (reify test2));;
let open IT in print (F.pair "/" F.int (F.list ";" (F.pair "," F.rat int_list))) (xreify_sampler (collect 1 (map_sampler accum_simple sample_rejection)) (reify test2));;
let open IT in print (F.pair "/" F.int (F.list ";" (F.pair "," F.rat int_list))) (xreify_sampler (collect 3 (map_sampler accum_simple sample_rejection)) (reify test2));;
module F=Format;;
let open IT in print (F.pair "/" F.int (F.list ";" (F.pair "," F.rat (F.paren int_list)))) (xreify_sampler (collect 3 (map_sampler accum_simple sample_rejection)) (reify test2));;
let open IT in print (F.pair "/" F.int (F.list ";" (F.pair "," F.rat (F.paren int_list)))) (xreify_sampler (collect 2 (map_sampler accum_simple sample_rejection)) (reify test2));;
let open IT in print (F.pair "" F.ignore (F.list ";" (F.pair "," F.rat (F.paren int_list)))) (xreify_sampler (collect 2 (map_sampler accum_simple sample_rejection)) (reify test2));;
#use "test-p.ml";;
let open IT in print (F.pair "" F.ignore (F.list ";" (F.pair "," F.rat (F.paren int_list)))) (xreify_sampler (collect 2 (map_sampler accum_simple sample_rejection)) (reify test2));;
#use "test-p.ml";;
let open IT in print (F.pair "" F.ignore (F.list ";" (F.pair "," F.rat (F.paren int_list)))) (xreify_sampler (collect 2 (map_sampler accum_simple sample_rejection)) (reify test2));;
let open IT in print (F.pair "" F.ignore (F.bracket (F.list ";" (F.pair "," F.rat (F.paren int_list))))) (xreify_sampler (collect 2 (map_sampler accum_simple sample_rejection)) (reify test2));;
let open IT in print (F.pair "" F.ignore ((F.list ";" (F.pair ":" F.rat (F.paren int_list))) |> F.bracket)) (xreify_sampler (collect 2 (map_sampler accum_simple sample_rejection)) (reify test2));;
let open IT in print (F.pair "" F.ignore ((F.list ";" (F.pair ":" (F.paren int_list |> F.rat))) |> F.bracket)) (xreify_sampler (collect 2 (map_sampler accum_simple sample_rejection)) (reify test2));;
let open IT in print (F.pair "" F.ignore (((F.pair ":" F.rat (F.paren int_list)) |> F.list ";") |> F.bracket)) (xreify_sampler (collect 2 (map_sampler accum_simple sample_rejection)) (reify test2));;
let open IT in print (F.pair "" F.ignore ((F.pair ":" F.rat (F.paren int_list)) |> F.list ";" |> F.bracket)) (xreify_sampler (collect 2 (map_sampler accum_simple sample_rejection)) (reify test2));;
let open IT in print (F.pair "" F.ignore (F.pair ":" F.rat (F.paren int_list)) |> F.list ";" |> F.bracket) (xreify_sampler (collect 2 (map_sampler accum_simple sample_rejection)) (reify test2));;
let open IT in print (F.pair "" F.ignore ((F.paren int_list |> F.pair ":" F.rat) ) |> F.list ";" |> F.bracket)) (xreify_sampler (collect 2 (map_sampler accum_simple sample_rejection)) (reify test2));;
let open IT in print (F.pair "" F.ignore (F.paren int_list |> F.pair ":" F.rat |> F.list ";" |> F.bracket)) (xreify_sampler (collect 2 (map_sampler accum_simple sample_rejection)) (reify test2));;
let open IT in xreify_sampler (collect 100 (sample_importance_map 1)) (reify test2);;
let open IS in xreify_sampler (collect 100 (sample_importance_map 1)) (reify test2);;
let open IS in xreify_sampler (collect 100 (sample_importance_map 1)) (reify test2) ();;
let open IS in xreify_sampler (collect 100 (sample_importance_map 1)) (reify test2);;
#use "test-p.ml";;
let open IS in xreify_sample_collector 100 (sample_importance_map 1) test2;;
let open IS in xreify_sample_collector 100 (sample_importance_map 1) test2 ();;
let open IS in xreify_sample_collector 1000 (sample_importance_map 1) test2 ();;
let open IS in xreify_sample_collector 1000 (sample_importance_map ) test2 ();;
let open IS in xreify_sample_collector 1000 (sample_importance_map 2) test2 ();;
let open IS in xreify_sample_collector 100 (sample_importance_map 2) test2 ();;
let open IS in xreify_sample_collector 100 (sample_importance_map 0) test2 ();;
Dist.normalise' $> let open IS in xreify_sample_collector 100 (sample_importance_map 0) test2 ();;
open Pair;;
Dist.normalise' $> let open IS in xreify_sample_collector 100 (sample_importance_map 0) test2 ();;
Dist.normalise $> let open IS in xreify_sample_collector 100 (sample_importance_map 0) test2 ();;
Dist.normalise (snd let open IS in xreify_sample_collector 100 (sample_importance_map 0) test2 ());;
let open IS in xreify_sample_collector 100 (sample_importance_map 0) test2 () |> snd;;
let open IS in xreify_sample_collector 100 (sample_importance_map 0) test2 () |> snd |> Dist.normalise' |> Dist.wmap id;;
let open IS in xreify_sample_collector 100 (sample_importance_map 0) test2 () |> snd |> Dist.normalise' |> Dist.map_weights id;;
let open IS in xreify_sample_collector 100 (sample_importance_map 0) test2 () |> snd |> Dist.normalise |> Dist.map_weights id;;
let open IS in xreify_sample_collector 100 (sample_importance_map 0) test2 () |> snd |> Dist.normalise |> Dist.map_weights Dist.weight_to_float;;
let open IS in xreify_sample_collector 100 (sample_importance_map 0) test2 () |> snd |> Dist.normalise |> Dist.map_weights Dist.to_float;;
let open IS in xreify_sample_collector 100 (sample_importance_map 2) test2 () |> snd |> Dist.normalise |> Dist.map_weights Dist.to_float;;
#use "test-p.ml";;
reify test2;;
print int_list $ reify test2;;
print int_list $ exact_reify test2;;
let open SS in xreify_sample_collector 100 (sample_importance_map 2) test2 () |> snd |> Dist.normalise |> Dist.map_weights Dist.to_float;;
let open SS in xreify_sample_collector 100 (sample_importance_map 2) test2 ()
;;
let open SS in xreify_sample_collector 100 (accum_weighted *|* sample_importance 2) test2 ()
;;
let open SS in xreify_sampler (collect 100 (accum_weighted *|* sample_importance 2)) test2 ()
;;
let open SS in xreify_sampler (collect 100 (accum_weighted *|* sample_importance 2)) (reify test2) ()
;;
#use "test-p.ml";;
let open SS in xreify_sampler (collect 100 (accum_weighted *|* sample_importance 2)) (reify test2) ()
;;
let open ST in xreify_sampler (collect 100 (accum_weighted *|* sample_importance 2)) (reify test2);;
reify (fun () -> repeat 3 flip);;
let rec repeat n f = if n=0 then [] else f ():: (n-1);;
let rec repeat n f = if n=0 then [] else f ():: repeat (n-1) f;;
reify (fun () -> repeat 3 flip);;
reify (fun () -> flip ());;
flip;;
reify (fun () -> repeat 3 (fun () -> flip (1%2)));;
print int_list $ reify (fun () -> repeat 3 (fun () -> flip (1%2)));;
print (F.list "," F.bool) $ reify (fun () -> repeat 3 (fun () -> flip (1%2)));;
print (F.list "," F.int) $ reify (fun () -> repeat 3 (fun () -> bernoulli (1%2)));;
print (F.list "," F.bool) $ reify (fun () -> repeat 3 (fun () -> flip (1%2)));;
print (F.list "," F.bool) $ reify (fun () -> let l = repeat 3 (fun () -> flip (1%2)) in l);;
print (F.list "," F.bool) $ reify (fun () -> let l = repeat 3 (fun () -> flip (1%2)) in List.nth1 1 l);;
print (F.list "," F.bool) $ reify (fun () -> let l = repeat 3 (fun () -> flip (1%2)) in List.nth 1 l);;
print (F.list "," F.bool) $ reify (fun () -> let l = repeat 3 (fun () -> flip (1%2)) in List.nth l 1);;
print (F.list "," F.bool) $ reify (fun () -> let l = repeat 3 (fun () -> flip (1%2)) in l);;
oberve;;
observe;;
print (F.list "," F.bool) $ reify (fun () -> observe (const true) (fun () -> repeat 3 (fun () -> flip (1%2));;
print (F.list "," F.bool) $ reify (fun () -> observe (const true) (fun () -> repeat 3 (fun () -> flip (1%2))));;
print (F.list "," F.bool) $ reify (fun () -> observe (fun l -> flip (1%2)) (fun () -> repeat 3 (fun () -> flip (1%2))));;
print (F.list "," F.bool) $ reify (fun () -> observe (fun l -> flip (1%4)) (fun () -> repeat 3 (fun () -> flip (1%2))));;
print (F.list "," F.bool) $ reify (fun () -> observe (fun l -> flip (1%4)) (fun () -> repeat 2 (fun () -> flip (1%2))));;
print (F.list "," F.bool) $ reify (fun () -> observe (fun l -> flip (1)) (fun () -> repeat 2 (fun () -> flip (1%2))));;
print (F.list "," F.bool) $ reify (fun () -> observe (fun l -> flip (1%1)) (fun () -> repeat 2 (fun () -> flip (1%2))));;
print (F.list "," F.bool) $ reify (fun () -> observe (fun l -> flip (1%2)) (fun () -> (flip (1%2),flip (1%2))));;
print (F.pair "," F.bool) $ reify (fun () -> observe (fun l -> flip (1%2)) (fun () -> (flip (1%2),flip (1%2))));;
print (F.pair "," F.bool F.bool) $ reify (fun () -> observe (fun l -> flip (1%2)) (fun () -> (flip (1%2),flip (1%2))));;
print (F.pair "," F.bool F.bool) $ reify (fun () -> observe (fun (s1,s2) -> flip (if s1=s2 (3%4) else (1%4)) (fun () -> (flip (1%2),flip (1%2))));;
print (F.pair "," F.bool F.bool) $ reify (fun () -> observe (fun (s1,s2) -> flip (if s1=s2 then 3%4 else 1%4)) (fun () -> (flip (1%2),flip (1%2))));;
print (F.pair "," F.bool F.bool) $ exact_reify (fun () -> observe (fun (s1,s2) -> flip (if s1=s2 then 3%4 else 1%4)) (fun () -> (flip (1%2),flip (1%2))));;
11025/5
;;
print (F.pair "," F.bool F.bool) $ exact_reify (fun () -> observe (fun (s1,s2) -> flip (if s1=s2 then 3%4 else 1%4)) (fun () -> (flip (1%2),flip (1%2))));;
curry
;;
let z = uncurry (+);;
curry
;;
let q=curry;;
let q=uncurry;;
q (+) (3,4);;
q;;
ListM.return
;;
ListM.return;;
open Monads;;
ListM.return;;
curry ListM.return;;
let ret = curry ListM.return;;
ret 1;;
ret;;
ret "a";;
#use "test-p.ml";;
print F.int (exact_reify $ fun () -> roller () 1)ll
;;
print F.int (exact_reify $ fun () -> roller () 1);;
print F.int (exact_reify $ let r=roller () in variable_elim (fun _ -> r 1) 1);;
variable_elim;;
print F.int (exact_reify $ let r=roller () in r 1);;
print F.int (exact_reify $ fun () -> let r=roller () in variable_elim (fun _ -> r 1) 1);;
print F.int (exact_reify $ fun () -> let r=memo (fun k -> die ()) in variable_elim (fun _ -> r 1) 1);;
print F.int (exact_reify $ fun () -> let r=memo (fun k -> uniform [1;2;3]) in variable_elim (fun _ -> r 1) 1);;
exact_reify $ fun () -> let r=memo (fun k -> uniform [1;2;3]) in variable_elim (fun _ -> r 1) 1;;
exact_reify (fun () -> let r=memo (fun k -> uniform [1;2;3]) in variable_elim (fun _ -> r 1) 1);;
open ProbM;;
exact_reify (fun () -> let r=memo (fun k -> uniform [1;2;3]) in variable_elim (fun _ -> r 1) 1);;
exact_reify (fun () -> let r=memo (fun k -> uniformly [|1;2;3|]) in variable_elim (fun _ -> r 1) 1);;
:q
Store.new_loc;;
Store.newloc;;
Store.new_loc;;
open Store;;
Store.new_loc;;
module P=Probstate.Make(WTreeAlt);;
open Lazydata;;
module P=Probstate.Make(WTreeAlt);;
module P=Probstate.Make(Probstate.TreeM);;
open Probstate;;
module P=Probstate.Make(Probstate.TreeM);;
P.D.reify;;
module P=Probstate.Make(Probstate.TreeM);;
print F.int (exact_reify $ fun () -> let r=memo (fun k -> uniform [1;2;3]) in variable_elim (fun _ -> r 1) 1);;
#use "test-p.ml";;
print F.int (exact_reify $ fun () -> let r=memo (fun k -> uniform [1;2;3]) in variable_elim (fun _ -> r 1) 1);;
print F.int (exact_reify $ fun () -> die ()  + die ());;
print F.int (reify $ fun () -> die ()  + die ());;
#use "test-p.ml";;
print F.int (reify $ fun () -> die ()  + die ());;
#use "test-p.ml";;
print F.int (reify $ fun () -> die ()  + die ());;
print F.int (reify $ fun () -> let r = roller () in List.map r [1;2;3;2;1]);;
print int_list (reify $ fun () -> let r = roller () in List.map r [1;2;3;2;1]);;
print int_list (reify $ fun () -> let r = roller () in List.map r [1;2;1]);;
#use "test-p.ml";;
print int_list (reify $ fun () -> let r = roller () in List.map r [1;2;1]);;
print int_list (reify $ fun () -> let r = (memo $ fun k -> die ()) in List.map r [1;2;1]);;
#use "test-p.ml";;
print int_list (reify $ fun () -> let r = (memo $ fun k -> die ()) in List.map r [1;2;1]);;
#use "test-p.ml";;
module PR=Probstate.MakeRef (TreeM);;
module PR=Probstate.MakeRef (Inference2.TreeM);;
open PR;;
print F.int (reify $ fun () -> uniform [1;2;3]);;
print F.int (reify $ fun () -> 42);;
module PO=Prob.Ops(PR);;
open PO
;;
print F.int (reify $ fun () -> uniform [1;2;3]);;
print F.int (reify $ fun () -> let r=roller () in uniform [1;2;3;4]);;
print F.int (reify $ fun () -> let r=roller () in 1);;
print F.int (reify $ fun () -> let r=letlazy die in 1);;
print F.int (reify $ fun () -> let r=memo (fun k -> die ()) in r 1);;
print F.int (reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4]) in r 1);;
print F.int (reify $ fun () -> let r=letlazy (fun () -> uniform [1;2;3;4]) in (r (), r()));;
print F.int (reify $ fun () -> let r=letlazy (fun () -> uniform [1;2;3;4]) in (r () + r()));;
print F.int (reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4]) in (r () + r()));;
print F.int (reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4]) in (r 1 + r 2));;
print F.int (reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4]) in (r 1 + r 1));;
#use "test-p.ml";;
print F.int (reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4]) in (r 1 + r 1));;
print F.int (reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4]) in (r 2 + r 1));;
print F.int (reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4]) in (r 1 + r 1));;
print int_list (reify $ fun () -> let r = (memo $ fun k -> die ()) in List.map r [1;2;1]);;
#use "test-p.ml";;
print int_list (reify $ fun () -> let r = (memo $ fun k -> die ()) in List.map r [1;2;1]);;
#use "test-p.ml";;
print int_list (reify $ fun () -> let r = (memo $ fun k -> die ()) in List.map r [1;2;1]);;
#use "test-p.ml";;
print int_list (reify $ fun () -> let r = (memo $ fun k -> die ()) in List.map r [1;2;1]);;
#use "test-p.ml";;
print int_list (reify $ fun () -> let r = (memo $ fun k -> die ()) in List.map r [1;2;1]);;
#use "test-p.ml";;
print int_list (reify $ fun () -> let r = (memo $ fun k -> die ()) in List.map r [1;2;1]);;
#use "test-p.ml";;
print int_list (reify $ fun () -> let r = (memo $ fun k -> die ()) in List.map r [1;2;1]);;
#use "test-p.ml";;
print int_list (reify $ fun () -> let r = (memo $ fun k -> die ()) in List.map r [1;2;1]);;
#use "test-p.ml";;
print F.bool (reify $ fun () -> flip 0.5);;
print F.bool (reify $ fun () -> let biased = letlazy (fun () -> flip 0.5) in let coin () = flip 0.5 || biased () in coin ());;
print F.bool (exact_reify $ fun () -> let biased = letlazy (fun () -> flip 0.5) in let coin () = flip 0.5 || biased () in coin ());;
print F.bool (reify $ fun () -> let biased = letlazy (fun () -> flip 0.5) in let coin () = flip 0.5 || biased () in coin ());;
(reify $ fun () -> let biased = letlazy (fun () -> flip 0.5) in let coin () = flip 0.5 || biased () in coin ());;
#use "test-p.ml";;
print F.int (reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4]) in (r 1 + r 1));;
print F.int (reify $ fun () -> let r=memo (fun k -> 2*k) in (r 1 + r 1));;
print F.int (reify $ fun () -> let r=memo (fun k -> 2*k) in (r 1 + r 1 + r 1));;
print F.int (reify $ fun () -> let r=memo (fun k -> 3*k) in (r 1 + r 1 + r 1));;
print F.int (reify $ fun () -> let r=memo (fun k -> 2*k) in (r 1 + r 1 + r 1));;
#use "test-p.ml";;
print F.int (reify $ fun () -> let r=memo (fun k -> 2*k) in (r 1 + r 1 + r 1));;
print F.int (reify $ fun () -> log "starting"; let r=memo (fun k -> 2*k) in log "got memoiser"; (r 1 + r 1 + r 1));;
print F.int (reify $ fun () -> log "starting"; let r=memo (fun k -> log "computing"; 2*k) in log "got memoiser"; (r 1 + r 1 + r 1));;
#use "test-p.ml";;
print F.int (reify $ fun () -> log "starting"; let r=memo (fun k -> log "computing"; 2*k) in log "got memoiser"; (r 1 + r 1 + r 1));;
#use "test-p.ml";;
print F.int (reify $ fun () -> log "starting"; let r=memo (fun k -> log "computing"; 2*k) in log "got memoiser"; (r 1 + r 1 + r 1));;
#use "test-p.ml";;
print F.int (reify $ fun () -> log "starting"; let r=memo (fun k -> log "computing"; 2*k) in log "got memoiser"; (r 1 + r 1 + r 1));;
print F.int (reify $ fun () -> log "starting"; let r=memo (fun k -> log "computing"; 2*k) in log "got memoiser"; (r 1 + r 2 + r 1));;
print F.int (reify $ fun () -> log "starting"; let r=memo (fun k -> log "computing"; uniform [1;2;3]) in log "got memoiser"; (r 1 + r 2 + r 1));;
print int_list (reify $ fun () -> log "starting"; let r=memo (fun k -> log "computing"; uniform [1;2;3]) in log "got memoiser"; [r 1; r 2; r 1]);;
#use "test-p.ml";;
print int_list (reify $ fun () -> log "starting"; let r=memo (fun k -> log "computing"; uniform [1;2;3]) in log "got memoiser"; [r 1; r 2; r 1]);;
#use "test-p.ml";;
print int_list (reify $ fun () -> log "starting"; let r=memo (fun k -> log "computing"; uniform [1;2;3]) in log "got memoiser"; [r 1; r 2; r 1]);;
#use "test-p.ml";;
print int_list (reify $ fun () -> log "starting"; let r=memo (fun k -> log "computing"; uniform [1;2;3]) in log "got memoiser"; [r 1; r 2; r 1]);;
#use "test-p.ml";;
print int_list (reify $ fun () -> log "starting"; let r=memo (fun k -> log "computing"; uniform [1;2;3]) in log "got memoiser"; [r 1; r 2; r 1]);;
#use "test-p.ml";;
print int_list (reify $ fun () -> log "starting"; let r=memo (fun k -> log "computing"; uniform [1;2;3]) in log "got memoiser"; [r 1; r 2; r 1]);;
#use "test-p.ml";;
print int_list (reify $ fun () -> log "starting"; let r=memo (fun k -> log "computing"; uniform [1;2;3]) in log "got memoiser"; [r 1; r 2; r 1]);;
print int_list (reify $ fun () -> log "starting"; let r=memo (fun k -> log "computing"; uniform [1;2;3]) in log "got memoiser"; List.map r [1; 2; 1]);;
print int_list (exact_reify $ fun () -> log "starting"; let r=memo (fun k -> log "computing"; uniform [1;2;3]) in log "got memoiser"; List.map r [1; 2; 1]);;
#use "test-p.ml";;
print int_list (exact_reify $ fun () -> log "starting"; let r=memo (fun k -> log "computing"; uniform [1;2;3]) in log "got memoiser"; List.map r [1; 2; 1]);;
print int_list (exact_reify $ fun () -> log "starting"; let r=memo (fun k -> log "computing"; uniform [1;2;3]) in log "got memoiser"; map r [1; 2; 1]);;
exact_reify (fun () -> let r=memo (fun k -> uniformly [|1;2;3|]) in variable_elim (fun _ -> r 1) 1);;
open ProbM;;
exact_reify (fun () -> let r=memo (fun k -> uniformly [|1;2;3|]) in variable_elim (fun _ -> r 1) 1);;
exact_reify (fun () -> let r=memo (fun k -> uniformly [|1;2;3|]) in List.map r [1;2;1]);;
open ProbM;;
exact_reify (fun () -> let r=memo (fun k -> uniformly [|1;2;3|]) in List.map r [1;2;1]);;
#use "test-p.ml";;
exact_reify (fun () -> let r=memo (fun k -> uniformly [|1;2;3|]) in List.map r [1;2;1]);;
print int_list (exact_reify $ fun () -> log "starting"; let r=memo (fun k -> log "computing"; uniform [1;2;3]) in log "got memoiser"; map r [1; 2; 1]);;
print int_list (reify $ fun () -> log "starting"; let r=memo (fun k -> log "computing"; uniform [1;2;3]) in log "got memoiser"; map r [1; 2; 1]);;
#use "test-p.ml";;
print int_list (reify $ fun () -> log "starting"; let r=memo (fun k -> log "computing"; uniform [1;2;3]) in log "got memoiser"; map r [1; 2; 1]);;
Pair.pair_withll
Pair.pair_with;;
Pair.pair;;
open Utils;;
Pair.pair;;
Pair.pair_with;;
#use "test-p.ml";;
print int_list (reify $ fun () -> log "starting"; let r=memo (fun k -> log "computing"; uniform [1;2;3]) in log "got memoiser"; map r [1; 2; 1]);;
print int_list (reify $ fun () -> log "starting"; let r=memo (fun k -> uniform [1;2;3]) in log "got memoiser"; map r [1; 2; 1]);;
print int_list (exact_reify $ fun () -> log "starting"; let r=memo (fun k -> log "computing"; uniform [1;2;3]) in log "got memoiser"; map r [1; 2; 1]);;
#use "test-p.ml";;
collect;;
collect';;
ref 34
;;
ref _;;
#use "hanstest.ml#
;:
"''
#use "hanstest.ml";;
#use "schenker.ml";;
print F.int (exact_reify $ fun () -> let r=roller () in variable_elim (fun _ -> r 1) 1);;
#use "grammar.ml";;
:q
#use "schenker.ml"
;;
#use "schenker.ml";;
gen 1;;
gen 10;;
#use "schenker.ml";;
gen 10;;
#use "schenker.ml";;
parses 10 [2, Note (O, 0); 1, Note (O, 5); 1, Note (O, 0)];;
#use "schenker.ml";;
parses 10 [2, Note (O, 0); 1, Note (O, 5); 1, Note (O, 0)];;
parses 10 [1, Note (O, 0); 1, Note (O, 5); 1, Note (O, 0)];;
parses 2 [1, Note (O, 0); 1, Note (O, 5); 1, Note (O, 0)];;
#use "schenker.ml";;
parses 2 [1, Note (O, 0); 1, Note (O, 5); 1, Note (O, 0)];;
parses 2 [1, Note (O, 0); 2, Note (O, 5); 1, Note (O, 0)];;
parses 20 [1, Note (O, 0); 2, Note (O, 5); 1, Note (O, 0)];;
parses 1000 [1, Note (O, 0); 2, Note (O, 5); 1, Note (O, 0)];;
parses 1000 [1, Note (O, 0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O, 0)];;
parses 100 [1, Note (O, 0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O, 0)];;
parses 1000 [1, Note (O, 0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O, 0)];;
parses 5000 [1, Note (O, 0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O, 0)];;
#use "schenker.ml";;
MP1.seq;;
StrP.parse_all;;
#use "schenker.ml";;
parse1 10 mozart5000 [1, Note (O, 0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O, 0)];;
parse1 10 mozart284;;
parse1 100 mozart284;;
parse1 1000 mozart284;;
parse1 10000 mozart284;;
parse1 100 "1[A4]:;;
";;
parse1 100 "1[A4";;
parse1 1900 "1[A4";;
parse1 1900 "1[A4]";;
parse1 1900 "1[A4] 1[D3]";;
parse1 100 "1[A4] 1[D3]";;
parse1 10 "1[A4] 1[D3]";;
#use "schenker.ml";;
parse1 100 "1[A4] 1[D3]";;
parses 5000 [1, Note (O, 0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O, 0)];;
open P;
open P;;
reify (fun () -> 43);;
exact_reify (fun () -> 43);;
#use "schenker.ml";;
I.Explore.print;;
#use "schenker.ml";;
I.print;;
I.Explore.print;;
#use "schenker.ml";;
I.Explore.print;;
I.print;;
module II=I;;
reify (fun () -> 43);;
P.reify (fun () -> 43);;
open P;;
reify (fun () -> 43);;
reify (fun () -> let var = new_var () in 43);;
reify (fun () -> let var = new_var () in read var);;
#use "schenker.ml";;
reify (fun () -> let var = new_var () in read var);;
reify (fun () -> let var = new_var () in unify var 12; read var);;
reify (fun () -> let var = new_var () in unify var 12; unify var 12; read var);;
reify (fun () -> let var = new_var () in unify var 12; unify var 13; read var);;
#use "schenker.ml";;
parses 5000 [1, Note (O, 0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O, 0)];;
parses 5000 [1, Note (O, 0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)];;
parses 10000 [1, Note (O, 0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)];;
#use "schenker.ml";;
parses' 10000 [1, Note (O, 0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)];;
#use "schenker.ml";;
parses' 10000 [Note (O, 3); 1, Note (O,5); 1, Note (O, 0)];;
parses' 10000 [1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)];;
#use "schenker.ml";;
parses 10000 [1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)];;
parses' 10000 [1, Note (O, 3)];;
#use "schenker.ml";;
parses' 1 [1, Note (O, 3)];;
#use "schenker.ml";;
parses' 1 [1, Note (O, 0)];;
#use "schenker.ml";;
parses 1 [1, Note (O, 0)];;
parses 100 [1, Note (O, 0)];;
parses 1000 [1, Note (O, 0)];;
parses 10000 [1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)];;
parses' 10000 [1, Note (O, 0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)];;
#use "schenker.ml";;
parses 1000 [1, Note (O, 0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)];;
parses 1000 [1, Note (O, 0); 1, Note (O,0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)];;
parses 5000 [1, Note (O, 0); 1, Note (O,0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)];;
#use "schenker.ml";;
parses 5000 [1, Note (O, 0); 1, Note (O,0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)];;
open SchP
;;
open SchP
;;
parses 5000 [1, Note (O, 0); 1, Note (O,0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)];;
#use "schenker.ml";;
parses 5000 [1, Note (O, 0); 1, Note (O,0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)]);;
parses 5000 [1, Note (O, 0); 1, Note (O,0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)];;
parses;
;
parses;;
values (parses 5000 [1, Note (O, 0); 1, Note (O,0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)]);;
List.iter SchP.pprint (values (parses 5000 [1, Note (O, 0); 1, Note (O,0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)]));;
#use "schenker.ml";;
List.iter SchP.pprint (values (parses 5000 [1, Note (O, 0); 1, Note (O,0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)]));;
#use "schenker.ml";;
List.iter SchP.pprint (values (parses 5000 [1, Note (O, 0); 1, Note (O,0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)]));;
#use "schenker.ml";;
List.iter SchP.pprint (values (parses 5000 [1, Note (O, 0); 1, Note (O,0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)]));;
#use "schenker.ml";;
List.iter SchP.pprint (values (parses 5000 [1, Note (O, 0); 1, Note (O,0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)]));;
#use "schenker.ml";;
List.iter SchP.pprint (values (parses 5000 [1, Note (O, 0); 1, Note (O,0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)]));;
#use "schenker.ml";;
List.iter SchP.pprint (values (parses 5000 [1, Note (O, 0); 1, Note (O,0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)]));;
#use "schenker.ml";;
List.iter SchP.pprint (values (parses 5000 [1, Note (O, 0); 1, Note (O,0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)]));;
#use "schenker.ml";;
List.iter SchP.pprint (values (parses 5000 [1, Note (O, 0); 1, Note (O,0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)]));;
print_endline;;
SchP.pprint;;
#use "schenker.ml";;
List.iter SchP.pprint (values (parses 5000 [1, Note (O, 0); 1, Note (O,0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)]));;
#use "schenker.ml";;
List.iter SchP.pprint (values (parses 5000 [1, Note (O, 0); 1, Note (O,0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0)]));;
List.iter SchP.pprint (values (parses 5000 [1, Note (O, 0); 1, Note (O,0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0); 1, Note (O, 0)]));;
List.iter (fun (w,a) -> Printf.printf "p=%g.\n"; SchP.pprint a) (parses 5000 [1, Note (O, 0); 1, Note (O,0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0); 1, Note (O, 0)]);;
List.iter (fun (w,a) -> Printf.printf "p=%g.\n" w; SchP.pprint a) (parses 5000 [1, Note (O, 0); 1, Note (O,0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0); 1, Note (O, 0)]);;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (parses 5000 [1, Note (O, 0); 1, Note (O,0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0); 1, Note (O, 0)]);;
#use "schenker.ml";;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (parses 5000 [1, Note (O, 0); 1, Note (O,0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0); 1, Note (O, 0)]);;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (parses 5000 (List.map (fun p -> p) [1, Note (O, 0); 1, Note (O,0); 1, Note (O, 5); 1, Note (O, 3); 1, Note (O,5); 1, Note (O, 0); 1, Note (O, 0)]));;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (parses 5000 (List.map (fun p -> (1, N (O,p))) [0,0,0]));;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (parses 5000 (List.map (fun p -> (1, Note (O,p))) [0,0,0]));;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (parses 5000 (List.map (fun p -> (1, Note (O,p))) [0;0;0]));;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (parses 5000 (List.map (fun p -> (1, Note (O,p))) [12,3,2,3,0,3,2,3]));;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (parses 5000 (List.map (fun p -> (1, Note (O,p))) [12;3;2;3;0;3;2;3]));;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (parses 15000 (List.map (fun p -> (1, Note (O,p))) [12;3;2;3;0;3;2;3]));;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (parses 15000 (List.map (fun p -> (1, Note (O,p))) [12;3;2;3]));;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (parses 15000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]));;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (parses 15000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2;3]));;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (parses 25000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2;3]));;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (parses 25000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0]));;
List.member;;
List.mem;;
not;;
#use "schenker.ml";;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (parses 25000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0]));;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (parses 25000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3]));;
List.sort;;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (List.sort (parses 25000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3])));;
#use "schenker.ml";;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (List.sort (parses 25000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3])));;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (List.sort (parses 25000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2;3])));;
#use "schenker.ml";;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (List.sort (parses 25000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2;3])));;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (List.sort (parses 50000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2;3])));;
#use "schenker.ml";;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (List.sort (parses 50000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2;3])));;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (List.sort (parses 10000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2;3])));;
#use "schenker.ml";;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (List.sort (parses 10000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2;3])));;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (List.sort (parses 20000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2;3])));;
List.rep;;
String.make;;
String.make 5 '.';;
#use "schenker.ml";;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (List.sort (parses 20000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2;3])));;
#use "schenker.ml";;
List.iter (fun (w,a) -> Printf.printf "\n\np=%g.\n" w; SchP.pprint a) (List.sort (parses 20000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2;3])));;
List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; SchP.pprint a) (List.sort (parses 20000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2;3])));;
#use "schenker.ml";;
List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; SchP.pprint a) (List.sort (parses 20000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2;3])));;
#use "schenker.ml";;
List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; SchP.pprint a) (List.sort (parses 20000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2;3])));;
#use "schenker.ml";;
List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; SchP.pprint a) (List.sort (parses 20000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2;3])));;
#use "schenker.ml";;
List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; SchP.pprint a) (List.sort (parses 20000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2;3])));;
Array.nth;;
module Ar=Array;;
Filename.concat (Findlib.package_directory
             "batteries");;
Filename.concat (Findlib.package_directory "batteries");;
Filename.concat (Findlib.package_directory "batteries") "battop.ml";;
Format.err_formatter Filename.concat (Findlib.package_directory "batteries") "battop.ml";;
Toploop.use_silently;;
Filename.concat (Findlib.package_directory "batteries") "battop.ml";;
module B=Batteries;;
module L=BatMap;;
module L=List;;
List.last;;
Batteries.List.last;;
List.last;;
Batteries.List.last;;
#help
;;
help;;
?;;
#help
;;
#thread;;
Batteries.List.last;;
#use "schenker.ml"
;;
#use "schenker.ml";;
observe;;
#help;;
#use "schenker.ml";;
open BatPervasives;;
#use "schenker.ml";;
module Lz=Lazy;;
#use "schenker.ml";;
module Lz=Lazy;;
#use "schenker.ml";;
List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; SchP.pprint a) (List.sort (parses 20000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3])));;
parses 200 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]));;
parses 200 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]);;
parses 200 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0]);;
parses 2000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3]);;
parses 2000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2;3]);;
parses 10000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2;3]);;
#use "schenker.ml";;
parses';;
#use "schenker.ml";;
parses 10000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]);;
parses 10000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2;3]);;
parses 10000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]);;
parses 10000 (List.map (fun p -> (1, Note (O,p))) [0;3;2]);;
parses 10000 (List.map (fun p -> (1, Note (O,p))) [0;3]);;
parses 10000 (List.map (fun p -> (1, Note (O,p))) [0;3;2]);;
parses 1000 (List.map (fun p -> (1, Note (O,p))) [0;3;2]);;
parses 100 (List.map (fun p -> (1, Note (O,p))) [0;3;2]);;
parses 100 (List.map (fun p -> (1, Note (O,p))) [0;3;2;0]);;
#use "schenker.ml";;
parses 100 (List.map (fun p -> (1, Note (O,p))) [0;3;2;0]);;
parses 1000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;0]);;
parses 1000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2;3]);;
parses 10000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2;3]);;
parses 10000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3]);;
List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; SchP.pprint a) (List.sort (parses 2000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3])));;
List.sort;;
List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; SchP.pprint a) (BatList.sort (parses 2000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3])));;
#use "schenker.ml";;
List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; SchP.pprint a) (BatList.sort (parses 2000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3])));;
List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; pprint a) (BatList.sort (parses 2000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3])));;
List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; pprint a) (BatList.sort (parses 2000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2])));;
List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; pprint a) (BatList.sort (parses 10000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2])));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; pprint a) (BatList.sort (parses 2000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; pprint a) (BatList.sort (parses' 2000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2]))));;
§
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; pprint a) (BatList.sort (parses' 2000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; pprint a) (BatList.sort (parses' 3 2000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; pprint a) (BatList.sort (parses' 3 2000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; pprint a) (BatList.sort (parses' 1 2000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3;0;3;2]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; pprint a) (BatList.sort (parses' 1 2000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw (skeleton a)) (BatList.sort (parses' 1 2000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw (skeleton a)) (BatList.sort (parses' 1 10000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
SegParse.parse_all;;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw (skeleton a)) (BatList.sort (parses' 1 10000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw (skeleton a)) (BatList.sort (parses' 1 1000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 1000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 1000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 5000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 10000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 10000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 10000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 10000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 10000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 20000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 20000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
iterate;;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 20000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 20000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 20000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees 20000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees 20000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 20000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees 20000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 0 20000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 20000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 10000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 1000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 1000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 1000 (List.map (fun p -> (1, Note (O,p))) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 3 1000 (List.map (note 1) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 3 1000 (List.map (note 1) [0;3;2;3]))));;
note 1 10
;;
#use "schenker.ml";;
note 1 10;;
note;;
#use "schenker.ml";;
note;;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 3 1000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 1000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 3 1000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 2000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 2000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 10000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 15000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 20000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 10000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees 10000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees 20000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 4 1000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 3 1000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 3000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 5000 (List.map (note 1) [0;3;2;3]))));;
parse_df mozart284;;
parse_bf mozart284;;
#use "schenker.ml";;
parse_bf mozart284;;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 5000 (List.map (note 1) [0;3;2;3]))));;
gen 10 10
;;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 100 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 100 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 1000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 10000 (List.map (note 1) [0;3;2;3]))));;
#
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 10000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 10000 (List.map (note 1) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 10000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 5000 (List.map (note 1) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 5000 (List.map (note 1) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 5000 (List.map (note 1) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 5000 (List.map (note 1) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 5000 (List.map (note 1) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 1 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 5000 (List.map (note 1) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 5000 (List.map (note 1) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 5000 (List.map (note 1) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 5000 (List.map (note 1) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 5000 (List.map (note 1) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 5000 (List.map (note 1) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_trees' 2 5000 (List.map (note 1) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_with (skeleton ** parser) 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_with (skeleton ** parser') 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_with (skeleton ** parser') 5000 (List.map (note 1) ;
;;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_with (skeleton ** parser') 5000 (List.map (note 1) ;
;
;;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_with (skeleton ** parser') 5000 (List.map (note 1) ;;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_with (skeleton ** parser') 5000 (List.map (note 1);;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_with (skeleton ** parser') 5000 (List.map (note 1));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_with (skeleton ** parser') 5000 (List.map (note 1)));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_with (skeleton ** parser') 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_with' 2 (skeleton ** parser') 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_with' 2 (skeleton ** parser) 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_with' 2 (skeleton ** parser'') 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_with' 2 (skeleton ** parser') 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_with' 2 (skeleton ** parser) 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_with' 2 (skeleton ** parser) 2000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_with' 2 (skeleton ** parser') 2000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_with' 2 (skeleton ** parser'') 2000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_with' 2 (skeleton ** parser) 2000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_with' 2 (skeleton ** parser) 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_with' 2 (skeleton ** parser') 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_with' 2 (skeleton ** parser'') 5000 (List.map (note 1) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_with' 2 (skeleton ** parser'') 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_with' 2 (skeleton ** parser) 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (parse_with' 2 (skeleton ** parser') 5000 (List.map (note 1) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (sample_parse' 2 (skeleton ** SchP.start) 5000 (List.map (note 1) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (sample_parse' 2 (skeleton ** parse_with SchP.start) 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (sample_parse' 2 (skeleton ** parse_with SchP.start') 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (sample_parse' 2 (skeleton ** parse_with SchP.start) 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (sample_parse' 2 (skeleton ** parse_with SchP.start'') 5000 (List.map (note 1) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (sample_parse' 2 (skeleton ** parse_with SchP.start'') 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (sample_parse' 2 (skeleton ** parse_with SchP.start') 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (sample_parse' 2 (skeleton ** parse_with SchP.start) 5000 (List.map (note 1) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (sample_parse' 2 (skeleton ** parse_with SchP.start) 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (sample_parse' 2 (skeleton ** parse_with SchP.start') 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (sample_parse' 2 (skeleton ** parse_with SchP.start) 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (sample_parse' 2 (skeleton ** parse_with SchP.start'') 5000 (List.map (note 1) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (sample_parse' 2 (skeleton ** parse_with SchP.start'') 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (sample_parse' 2 (skeleton ** parse_with SchP.start') 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (sample_parse' 2 (skeleton ** parse_with SchP.start) 5000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (sample_parse' 2 (skeleton ** parse_with SchP.start) 10000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (sample_parse' 2 (skeleton ** parse_with SchP.start) 3000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (sample_parse' 2 (skeleton ** parse_with SchP.start) 2000 (List.map (note 1) [0;3;2;3]))));;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (sample_parse' 2 (skeleton ** parse_with SchP.start) 2000 (List.map (note 1) [0;3;2;3]))));;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (sample_parse' 2 (skeleton ** parse_with SchP.start) 5000 (List.map (note 1) [0;3;2;3]))));;
;;
Random.init;;
#use "schenker.ml";;
test 2000 [0;3;2;3];;
#use "schenker.ml";;
test 2000 [0;3;2;3];;
#use "schenker.ml";;
test 2000 [0;3;2;3];;
#use "schenker.ml";;
test 2000 [0;3;2;3];;
#use "schenker.ml";;
test 2000 [0;3;2;3];;
#use "schenker.ml";;
test 2000 [0;3;2;3];;
#use "schenker.ml";;
test 2000 [0;3;2;3];;
#use "schenker.ml";;
test 2000 [0;3;2;3];;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
Â
;;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
;;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
266 + 212 + 234 + 240 + 228 + 188;;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
198+250+184+226+218+202;;
#use "schenker.ml";;
198+250+184+226+218+202;;
test 10000 [0;3;2;3];;
LList.from_list;;
module LList = LList (P);;
LList.from_list;;
LList.from_list [0;3;2;3];;
(=);;
(==);;
(=:=);;
#use "schenker.ml";;
test 2000 [0;3;2;3];;
test 3000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
242 + 244 + 218 + 196 + 214 + 178;;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
274 + 212 + 222 + 236 +206 + 170;;
#use "schenker.ml";;
274 + 212 + 222 + 236 +206 + 170;;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
test 10000 [0;3;2;3];;
#use "schenker.ml";;
test 10000 [0;3;2;3];;
test 5000 [0;3;2;3;0;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3;0;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3;0;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3;0;3];;
test 5000 [0;3;2;3];;
test 1000 [0;3;2;3;0;3;2;3];;
test 5000 [0;3;2;3;0;3;2;3];;
#use "schenker.ml";;
test 1000 [0;3;2;3;0;3;2;3];;
#use "schenker.ml";;
test 1000 [0;3;2;3;0;3;2;3];;
#use "schenker.ml";;
test 1000 [0;3;2;3;0;3;2;3];;
force;;
#use "schenker.ml";;
reflect;;
exact_reify $ fun () -> uniform [1;2;3];;
reify $ fun () -> uniform [1;2;3];;
reify $ fun () -> uniform [1;2;3;4];;
reify $ fun () -> let n = letlazy (fun () -> uniform [1;2;3;4]) in n ();;
reify $ fun () -> let n = letvar (fun () -> uniform [1;2;3;4]) in n ();;
reify $ fun () -> let n = letvar (fun () -> uniform [1;2;3;4]) in force n;;
reify $ fun () -> let n = letvar (fun () -> uniform [1;2;3;4]) in constrain (fun n -> ()) n; force n;;
reify $ fun () -> let n = letvar (fun () -> uniform [1;2;3;4]) in constrain (fun n -> if n<2 then fail ()) n; force n;;
module IO = InfOps (P) (Explore);;
module IO = InfOps (P) (Inf2.Explore);;
open IO
;;
exact_reify $ fun () -> let n = letvar (fun () -> uniform [1;2;3;4]) in constrain (fun n -> if n<2 then fail ()) n; force n;;
reify_to_mdist $ fun () -> let n = letvar (fun () -> uniform [1;2;3;4]) in constrain (fun n -> if n<2 then fail ()) n; force n;;
MDist.to_dist (reify_to_mdist $ fun () -> let n = letvar (fun () -> uniform [1;2;3;4]) in constrain (fun n -> if n<2 then fail ()) n; force n);;
#use "schenker.ml";;
5/2;;
#use "schenker.ml";;
MDist.to_dist (reify_to_mdist $ fun () -> let n = letvar (fun () -> uniform [1;2;3;4]) in constrain (fun n -> if n<2 then fail ()) n; force n);;
test 1000 [0;3;2;3];;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
timeit (fun () -> List.iter (fun (w,a) -> Printf.printf "\n\np=%f.\n" w; BTree.draw a) (BatList.sort (sample_parse' 2 (skeleton ** parse_with SchP.start) 5000 (List.map (note 1) [0;3;2;3]))));;
#use "schenker.ml";;
test 1000 [0;3;2;3];;
#use "schenker.ml";;
test 1000 [0;3;2;3];;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
#use "schenker.ml";;
test 5000 [0;3;2;3];;
timeit test_trees 5000 [0;3;2;3];;
timeit (test_trees 5000 [0;3;2;3]);;
#use "schenker.ml";;
timeit (test_trees 5000 [0;3;2;3]);;
timeit (test_trees 3 5000 [0;3;2;3]);;
882.0 /. 13.8
;;
timeit (test_trees 3 5000 [0;3;2;3]);;
870.0 /. 13.9;;
timeit (test_trees 2 5000 [0;3;2;3]);;
210 / 4;;
210.0 /. 4.14;;
timeit (test_trees 2 5000 [0;3;2;3]);;
246.0 /. 4.2;;
timeit (test_trees 2 5000 [0;3;2;3]);;
288.0 /. 4.1;;
timeit (test_trees 2 10000 [0;3;2;3]);;
484.0 /. 8.35;;
timeit (test_trees 3 2000 [0;3;2;3]);;
334.0 /. 5.5;;
timeit (test_trees 3 2000 [0;3;2;3]);;
338.0 /. 5.5;;
timeit (test_trees 3 2000 [0;3;2;3]);;
326.0 /. 5.5;;
timeit (test_trees 2 5000 [0;3;2;3]);;
250.0 /. 4.1;;
timeit (test_trees 2 5000 [0;3;2;3]);;
timeit (test_trees 2 6000 [0;3;2;3]);;
timeit (test_trees 2 1200 [0;3;2;3]);;
timeit (test_trees 3 800 [0;3;2;3]);;
timeit (test_trees 3 500 [0;3;2;3]);;
timeit (test_trees 3 400 [0;3;2;3]);;
timeit (test_trees 3 350 [0;3;2;3]);;
timeit (test_trees 3 370 [0;3;2;3]);;
timeit (test_trees 2 2400 [0;3;2;3]);;
timeit (test_trees 3 720 [0;3;2;3]);;
#use "schenker.ml";;
test_analysis 3 100 [0;3;2;3];;
test_analyses 3 100 [0;3;2;3];;
#use "schenker.ml";;
test_analyses 3 100 [0;3;2;3];;
test_analyses 3 100 [0;3;2;3] ();;
sample_parse';;
SchP.start;;
#use "schenker.ml";;
SchP.start;;
test_analyses 3 100 [0;3;2;3] ();;
#use "schenker.ml";;
test_analyses 3 100 [0;3;2;3] ();;
test_analyses 3 100 [0;3;2;3;0;3;2;3] ();;
#use "schenker.ml";;
test_analyses 3 100 [0;3;2;3;0;3;2;3] ();;
test_analyses 3 200 [0;3;2;3;0;3;2;3] ();;
test_analyses 3 500 [0;3;2;3;0;3;2;3] ();;
test_analyses 2 500 [0;3;2;3;0;3;2;3] ();;
test_analyses 3 500 [0;3;2;3;0;3;2;3] ();;
#use "schenker.ml";;
test_analyses 3 500 [0;3;2;3;0;3;2;3] ();;
note 1 0;;
test_analyses 3 500 (List.map (note 1) [0;3;2;3;0;3;2;3]) ();;
#use "schenker.ml";;
test_analyses 3 500 (List.map (note 1) [0;3;2;3;0;3;2;3]) ();;
#use "schenker.ml";;
test_analyses 3 500 (List.map (note 1) [0;3;2;3;0;3;2;3]) ();;
timeit (test_analyses 3 1500 (List.map (note 1) [0;3;2;3;0;3;2;3]));;
timeit (test_analyses 3 1000 (List.map (note 1) [0;3;2;3;0;3;2;3]));;
#use "schenker.ml";;
timeit (test_analyses 3 1000 (List.map (note 1) [0;3;2;3;0;3;2;3]));;
#use "schenker.ml";;
timeit (test_analyses 3 1000 (List.map (note 1) [0;3;2;3;0;3;2;3]));;
#use "schenker.ml";;
timeit (test_analyses 3 1000 (List.map (note 1) [0;3;2;3;0;3;2;3]));;
#use "schenker.ml";;
timeit (test_analyses 3 1000 (List.map (note 1) [0;3;2;3;0;3;2;3]));;
#use "schenker.ml";;
timeit (test_analyses 3 1000 (List.map (note 1) [0;3;2;3;0;3;2;3]));;
#use "schenker.ml";;
timeit (test_analyses 3 1000 (List.map (note 1) [0;3;2;3;0;3;2;3]));;
timeit (test_trees 3 720 [0;3;2;3]);;
List.sum;;
sum;;
#use "schenker.ml";;
reify (fun () -> binomial 5);;
#use "schenker.ml";;
reify (fun () -> binomial 5);;
reify_to_mdist (fun () -> binomial 5);;
IO.reify_to_mdist (fun () -> binomial 5);;
MDist.to_dist (IO.reify_to_mdist (fun () -> binomial 5));;
#use "schenker.ml";;
timeit (test_trees 3 720 [0;3;2;3]);;
timeit (test_trees 2 100 [0;3;2;3]);;
gen 10 10
;;
#use "schenker.ml";;
timeit (test_trees 2 100 [0;3;2;3]);;
timeit (test_analyses 3 1000 (List.map (note 1) [0;3;2;3]));;
timeit (test_analyses 3 1000 (List.map (note 1) [12;3;2;3]));;
timeit (test_analyses 3 1000 (List.map (note 1) [12;3;2;3;0;3]));;
#use "schenker.ml";;
timeit (test_analyses 3 1000 (List.map (note 1) [12;3;2;3;0;3]));;
#use "schenker.ml";;
timeit (test_analyses 3 1000 (List.map (note 1) [12;3;2;3;0;3]));;
#use "schenker.ml";;
timeit (test_analyses 3 1000 (List.map (note 1) [12;3;2;3;0;3]));;
timeit (test_analyses 3 1000 (List.map (note 1) [12;3;2;3;0]));;
#use "schenker.ml";;
timeit (test_analyses 3 1000 (List.map (note 1) [12;3;2;3;0]));;
timeit (test_analyses 3 1000 (List.map (note 1) [12;3]));;
#use "schenker.ml";;
binomial12;;
binomial20;;
#use "schenker.ml";;
timeit (test_analyses 3 1000 (List.map (note 1) [12;3;2;3;0;3;2;3]));;
timeit (test_analyses 3 1000 (List.map (fun p -> note 1 (p+12)) [12;3;2;3;0;3;2;3]));;
timeit (test_trees 2 100 [0;3;2;3]);;
timeit (test_trees 2 1000 [0;3;2;3]);;
timeit (test_trees 2 1000 [24;15;14;15;12;5]);;
timeit (test_trees 3 1000 [24;15;14;15;12;5]);;
#use "schenker.ml";;
timeit (test_trees 3 1000 [24;15;14;15;12;5]);;
timeit (test_trees 3 4000 [24;15;14;15;12;5]);;
timeit (test_trees 3 10000 [24;15;14;15;12;5]);;
timeit (test_trees 4 1000 [24;15;14;15;12;5]);;
timeit (test_trees 4 2000 [24;15;14;15;12;15;14;15]);;
timeit (test_trees 5 200 [24;15;14;15;12;15;14;15]);;
timeit (test_trees 5 500 [24;15;14;15;12;15;14;15]);;
timeit (test_trees 4 5000 [24;15;14;15;12;15;14;15]);;
#use "schenker.ml";;
binomial;;
binomial 5;;
exact_reify $ fun () ->binomial 5;;
reify_to_mdist $ fun () ->binomial 5;;
#use "schenker.ml";;
reify_to_dist $ fun () ->binomial 5;;
#use "schenker.ml";;
reify_to_dist $ fun () ->binomial 5;;
reify_to_dist $ fun () ->binomial 20;;
binomial_tree 12;;
binomial_tree 20;;
reify_to_dist $ fun () ->binomial 20;;
timeit $ fun  () -> reify_to_dist $ fun () ->binomial 24;;
reify_to_dist $ fun () ->binomial 20;;
timeit $ fun  () -> reify_to_dist $ fun () ->binomial 24;;
timeit $ fun () -> binomial_tree 20;;
timeit $ fun () -> binomial_tree 24;;
timeit $ fun () -> binomial_tree 32;;
timeit $ fun  () -> reify_to_dist $ fun () ->binomial 32;;
timeit (test_trees 4 1000 [24;15;14;15;12;15;14;15]);;
timeit (test_analyses 3 1000 (List.map (fun p -> note 1 (p+12)) [12;3;2;3;0;3;2;3]));;
timeit (test_analyses 4 1000 (List.map (fun p -> note 1 (p+12)) [12;3;2;3;0;3;2;3]));;
#use "schenker.ml";;
timeit (test_analyses 4 1000 (List.map (fun p -> note 1 (p+12)) [12;3;2;3;0;3;2;3]));;
parse_with;;
timeit (test_analyses 4 1000 (List.map (fun p -> note 1 (p+12)) [12;3;2;3;0;3;2;3]));;
#use "schenker.ml";;
timeit (test_analyses 4 1000 (List.map (fun p -> note 1 (p+12)) [12;3;2;3;0;3;2;3]));;
timeit (test_analyses 4 100 (List.map (fun p -> note 1 (p+12)) [12;3;2;3;0;3;2;3]));;
timeit (test_analyses 4 200 (List.map (fun p -> note 1 (p+12)) [12;3;2;3;0;3;2;3]));;
timeit (test_analyses 2 200 (List.map (fun p -> note 1 (p+12)) [12;3;2;3;0;3;2;3]));;
timeit (test_analyses 3 200 (List.map (fun p -> note 1 (p+12)) [12;3;2;3;0;3;2;3]));;
#use "schenker.ml";;
BatList.sort;;
compare;;
#use "schenker.ml";;
timeit (test_analyses 3 200 (List.map (fun p -> note 1 (p+12)) [12;3;2;3;0;3;2;3]));;
module L=List;;
module L=BatList;;
:q
module L=Batteries.List;;
#use "schenker.ml";;
open monads
;
.
;
open Store;;
new_loc
;;
?
;;
!help;;
:help;;
Store.empty
;;
empty;;
open Store;;
empty;;
put 4 empty
;;
new_loc
;;
new_loc ();;
#use "init-gtk;;.ml";;
#use "init-gtk.ml";;
#help;;
swap
;;
Pair.swap;;
open Pair;;
#load "utils.cma";;
#load "util.cma";;
open Pair;;
open Pairs;;
#load "utils.cmo";;
open Pair;;
open Utils;;
Utils.Pair.swap;;
Utils.Pair.swap (1,2);;
let open Utils in Pair.swap (3,4);;
let open Utils in
Pair.swap (Pair.swap (3,4))
;;
open Utils
;;
( ** );;
let id2 = let open Pair in swap ** swap;;
id2
;;
id2 (4,5);;
id2 "fish:;;
;";;
id2 "fish";;
id2 (2,"fish");;
let id2 = let open Pair in swap ** swap : 'a * 'b -> 'a * 'b;;
let id2 : 'a * 'b -> 'a * 'b = let open Pair in swap ** swap;;
id2;;
id2 (3,4);;
id2;;
print "ello";;
println "ello";;
print_endline "hello";;
print (2,3);;
print_string (2,3);;
module Mod12 = Modulo(struct let modulus=12 end);;
open Utils;;
module Mod12 = Modulo(struct let modulus=12 end);;
open Mod12;;
fix 34;;
fix 10 +% 7;;
fix 10 +% 7 -% 16;;
module S = StateM(Utils.CHAR);;
module SO = MonadOps(S);;
SO.foldM (fun s x -> S.return (s+x)) 0 [1;2;3];;
SO.foldM (fun s x -> S.return (s+x)) 0 [1;2;3] |> 0;;
SO.foldM (fun s x -> S.return (s+x)) 0 [1;2;3] 0;;
SO.foldM (fun s x -> S.return (s+x)) 0 [1;2;3] 'a';;
module S = Monads.StateM(Utils.CHAR);;
module S = Monads.StateM(Utils.CHAR) : Monads.MONADSTATE;;
module S : Monads.MONADSTATE = Monads.StateM(Utils.CHAR);;
S.get;;
open Monads;;
module S = StateM(Utils.CHAR);;
module SO = MonadOps(S);;
SO.foldM (fun s x -> S.return (s+x)) 0 [1;2;3] 'a';;
module S = StateM(Utils.STRING;;
module S = StateM(Utils.STRING);;
module SO = MonadOps(S);;
SO.foldM (fun s x -> S.return (s+x)) 0 [1;2;3] "";;
SO.(foldM (fun s x -> S.upd (fun s -> s ^ "," ^ (string_of_int x)) >> S.return (s+x)) 0 [1;2;3] "");;
SO.(foldM (fun s x -> S.upd (fun s -> s ^ ":" ^ (string_of_int x)) >> S.return (s+x)) 0 [1;2;3] "");;
open Monads
;;
module ListST = ListT(ST);;
ListST.fold (fun l x -> ST.return (x::l)) [] (ST.return [1;2;3]);;
ListST.fold (fun l x -> ST.return (x::l)) [] (ST.return [1;2;3]) |> ST.run;;
#load "delimcc.cmo"
;;
ListST.fold (fun l x -> ST.return (x::l)) [] (ST.return [1;2;3]) |> ST.run;;
SO.foldM (fun s x -> S.return (s+x)) 0 [1;2;3] "";;
module S = StateM(Utils.CHAR);;
SO.foldM (fun s x -> S.return (s+x)) 0 [1;2;3] "";;
module SO = MonadOps(S);;
SO.foldM (fun s x -> S.return (s+x)) 0 [1;2;3] "";;
SO.foldM (fun s x -> S.return (s+x)) 0 [1;2;3] '';;
SO.foldM (fun s x -> S.return (s+x)) 0 [1;2;3] 'a'
;;
SO.foldM (fun s x -> S.return (s+x)) 0 [1;2;3] 'b';;
shift
;;
open Delimcc;;
shift;;
shift
;;
