importance_sample 1 10 $ fun () -> music2_main [B;A;Gsharp;A] [C;B;A;B];;
importance_sample 2 10 $ fun () -> music2_main [B;A;Gsharp;A] [C;B;A;B];;
importance_sample 2 10 $ fun () -> music2_main [E;B;A;Gsharp;A] [E;C;B;A;B];;
importance_sample 2 100 $ fun () -> music2_main [E;B;A;Gsharp;A] [E;C;B;A;B];;
importance_sample 2 100 $ fun () -> music2_main [E;C;B;A;Gsharp;A] [E;D;C;B;A;B];;
importance_sample 3 10 $ fun () -> music2_main [E;C;B;A;Gsharp;A] [E;D;C;B;A;B];;
timeit $ fun () -> importance_sample 3 10 (fun () -> music2_main [E;C;B;A;Gsharp;A] [E;D;C;B;A;B]);;
timeit $ fun () -> importance_sample 3 100 (fun () -> music2_main [E;C;B;A;Gsharp;A] [E;D;C;B;A;B]);;
timeit $ fun () -> importance_sample 2 100 (fun () -> music2_main [E;C;B;A;Gsharp;A] [E;D;C;B;A;B]);;
timeit $ fun () -> importance_sample 2 100 (fun () -> music2_main [E;E;A;C;B;A;Gsharp;A] [E;D;C;B;A;B]);;
timeit $ fun () -> importance_sample 2 10 (fun () -> music2_main [E;A;C;E;A;C;B;A;Gsharp;A] [E;D;C;B;A;B]);;
timeit $ fun () -> importance_sample 2 100 (fun () -> music2_main [E;A;C;E;A;C;B;A;Gsharp;A] [E;D;C;B;A;B]);;
timeit $ fun () -> importance_sample 3 10 (fun () -> music2_main [E;A;C;E;A;C;B;A;Gsharp;A] [E;D;C;B;A;B]);;
timeit $ fun () -> importance_sample 3 50 (fun () -> music2_main [E;A;C;E;A;C;B;A;Gsharp;A] [E;D;C;B;A;B]);;
timeit $ fun () -> importance_sample 4 20 (fun () -> music2_main [E;A;C;E;A;C;B;A;Gsharp;A] [E;D;C;B;A;B]);;
timeit $ fun () -> importance_sample 5 5 (fun () -> music2_main [E;A;C;E;A;C;B;A;Gsharp;A] [E;D;C;B;A;B]);;
exact_reify (fun () -> List.length (List.map transpose2 [C;C;C]))
;;
print F.int $ exact_reify (fun () -> List.length (List.map transpose2 [C;C;C]))
;;
print (F.list "," F.note) $ exact_reify (fun () -> (List.map transpose2 [C;C;C]))
;;
print (F.list "," F.note) $ exact_reify (fun () -> (List.map transpose2 [C;C;C]));;
print (F.list "," F.note) $ exact_reify (fun () -> (List.map transpose2 [C;C;C;C]));;
print (F.list "," F.note) $ exact_reify (fun () -> (List.map transpose2 [C;C;C]));;
reify_to_mdist (fun () -> (List.map transpose2 [C;C;C]));;
BatMap.binding $ reify_to_mdist (fun () -> (List.map transpose2 [C;C;C]));;
BatMap.bindings $ reify_to_mdist (fun () -> (List.map transpose2 [C;C;C]));;
BatMap.bindings $ reify_to_mdist (fun () -> (List.map transpose2 [C;C;C;C]));;
BatMap.bindings $ reify_to_mdist (fun () -> List.length (List.map transpose2 [C;C;C;C]));;
timeit $ fun () -> importance_sample 2 10 (fun () -> music2_main [E;C;B;A;Gsharp;A] [E;D;C;B;A;B]);;
timeit $ fun () -> importance_sample 2 50 (fun () -> music2_main [E;C;B;A;Gsharp;A] [E;D;C;B;A;B]);;
print (const "x") $ exact_reify (fun () -> lobserve (transform0 (to_lcons [E;A;Gsharp;A])) [B;A;B]);;
timeit $ fun () -> BatMap.bindings (reify_to_mdist (fun () -> lobserve (transform0 (to_lcons [E;A;Gsharp;A])) [B;A;B]));;
#use "test-p.ml";;
#use "examples/music2.ml";;
timeit $ fun () -> BatMap.bindings (reify_to_mdist (fun () -> lobserve (transform0 (to_lcons [E;A;Gsharp;A])) [B;A;B]));;
#use "test-p.ml";;
#use "examples/music2.ml";;
timeit $ fun () -> BatMap.bindings (reify_to_mdist (fun () -> lobserve (transform0 (to_lcons [E;A;Gsharp;A])) [B;A;B]));;
get_samples 1 $ fun () -> msuic2_main [E;Gsharp;A] [A;B];;
get_samples 1 $ fun () -> music2_main [E;Gsharp;A] [A;B];;
get_samples 100 $ fun () -> music2_main [E;Gsharp;A] [A;B];;
get_samples 1000 $ fun () -> music2_main [E;Gsharp;A] [A;B];;
get_samples 1000 $ fun () -> music2_main [E;A;Gsharp;A] [B;A;B];;
timeit $ fun () -> get_samples 1000 (fun () -> music2_main [E;A;Gsharp;A] [B;A;B]);;
timeit $ fun () -> get_samples 1000 main_simple;;
timeit $ fun () -> get_samples 2000 main_simple;;
timeit $ fun () -> get_samples' 2000 main_simple;;
timeit $ fun () -> get_samples'' 2000 main_simple;;
timeit $ fun () -> sample_importance 200 main_simple;;
timeit $ fun () -> sample_importance 2000 main_simple;;
#load "perftest.ml";;
#use "perftest.ml";;
#use "test-p.ml";;
from_list;;
Prob.LList.from_list;;
24 + 24 +13+13+13+13;;
importance_sample 3 10 $ fun () -> music2_main [E;A;Gsharp;A] [E;B;A;B];;
#load "perftest.ml";;
#use "perftest.ml";;
importance_sample 3 10 $ fun () -> music2_main [E;A;Gsharp;A] [E;B;A;B];;
importance_sample 3 1000 $ fun () -> music2_main [E;A;Gsharp;A] [E;B;A;B];;
print note_list $ exact_reify (fun () -> (List.map transpose2 [C;C;C]));;
print note_list $ exact_reify (fun () -> (List.map (dist.transpose_dist) [C;C;C]));;
print note_list $ exact_reify (fun () -> transform (from_list [C;C;C]));;
T.from_list;;
module TT=T;
module TT=T;;
transpose_dist;;
print note_list $ exact_reify (fun () -> (List.map (dist transpose_dist) [C;C;C]));;
print note_list $ exact_reify (fun () -> (List.map (dist transpose_dist) [C;C;C;C]));;
print note_list $ exact_reify (fun () -> LL.to_list (LL.from_list [C;C;C;C]));;
print note_list $ exact_reify (fun () -> LL.to_list (transform (LL.from_list [C;C])));;
print note_list $ reify (fun () -> LL.to_list (transform (LL.from_list [C;C])));;
print note_list $ reify (fun () -> LL.to_list (transform (LL.from_list [C])));;
#use "perftest.ml";;
print note_list $ reify (fun () -> LL.to_list (transform (LL.from_list [C])));;
print note_list $ reify (fun () -> LL.to_list (transform (LL.from_list [C;C])));;
print note_list $ reify (fun () -> music2_main [C;C] [C;G];;
reify (fun () -> music2_main [C;C] [C;G]);;
exact_reify (fun () -> music2_main [C;C] [C;G]);;
print (const "x") exact_reify (fun () -> music2_main [C;C] [C;G]);;
print (const "x") $ exact_reify (fun () -> music2_main [C;C] [C;G]);;
reify_to_mdist (fun () -> music2_main [C;C] [C;G]);;
BatMap.bindings $ reify_to_mdist (fun () -> music2_main [C;C] [C;G]);;
BatMap.bindings $ reify_to_mdist (fun () -> music2_main [C;C;G] [C;G]);;
importance_sample 2 100 $ fun () -> music2_main [E;A;Gsharp;A] [E;B;A;B];;
importance_sample 3 100 $ fun () -> music2_main [E;A;Gsharp;A] [E;B;A;B];;
importance_sample 3 10 $ fun () -> music2_main [E;A;Gsharp;A] [E;B;A;B];;
importance_sample 4 10 $ fun () -> music2_main [E;A;Gsharp;A] [E;B;A;B];;
importance_sample 5 10 $ fun () -> music2_main [E;A;Gsharp;A] [E;B;A;B];;
importance_sample 3 100 $ fun () -> music2_main [E;A;Gsharp;A] [E;B;A;B];;
importance_sample 3 100 $ fun () -> music2_main [C;G] [C;C];;
print (const "x") $ reify (fun () -> music2_main [C;G] [C;C]);;
print (const "x") $ reify (fun () -> music2_main [C] [C]);;
print (const "x") $ reify (fun () -> music2_main [C] [G]);;
print (note_list) $ reify (fun () -> transform_list [C]);;
#use "perftest.ml";;
print (note_list) $ reify (fun () -> transform_list [C]);;
#use "perftest.ml";;
print (note_list) $ reify (fun () -> transform_list [C]);;
#use "perftest.ml";;
print (note_list) $ reify (fun () -> transform_list [C]);;
print (const "x") $ reify (fun () -> music2_main [C] [G]);;
print (note_list) $ reify (fun () -> transform_list [C]);;
print (const "x") $ reify (fun () -> music2_main [C] [G]);;
WTreeAltM2.return;;
Treemonads.WTreeAltM2.return;;
Treemonads.WTreeAltM2.extend;;
Treemonads.WTreeAltM2.extend';;
Treemonads.WTreeAltM2.extend;;
Treemonads.WTreeAltM2.extend';;
Treemonads.WTreeAltM2.extend;;
repeat;;
( + );;
#use "test-p.ml";;
print F.int (reify big_test);;
print F.int (exact_reify big_test);;
iterate;;
List.iterate;;
#use "test-p.ml";;
iterate;;
#use "test-p.ml";;
print F.int (exact_reify big_test 2);;
print F.int (exact_reify $ big_test 2);;
timeit $ fun () -> print F.int (exact_reify $ big_test 2);;
timeit $ fun () -> print F.int (exact_reify $ big_test 4);;
timeit $ fun () -> print F.int (exact_reify $ big_test 5);;
timeit $ fun () -> print F.int (exact_reify $ big_test 6);;
print F.int (reify $ big_test 2);;
4 mod 3;;
#use "test-p.ml";;
print F.int (reify $ big_test 2);;
timeit $ fun () -> print F.int (exact_reify $ big_test 5);;
timeit $ fun () -> print F.int (exact_reify $ big_test 6);;
timeit $ fun () -> print F.int (exact_reify $ big_test 7);;
timeit $ (fun () -> get_samples 1000 $ big_test 7);;
timeit $ (fun () -> get_samples' 1000 $ big_test 7);;
timeit $ (fun () -> get_samples'' 1000 $ big_test 7);;
timeit $ fun () -> print F.int (exact_reify $ big_test 5);;
timeit $ fun () -> print F.int (exact_reify $ big_test 6);;
timeit $ fun () -> print F.int (exact_reify $ big_test 7);;
#use "test-p.ml";;
timeit $ fun () -> print F.int (exact_reify $ big_test 2);;
#use "test-p.ml";;
timeit $ fun () -> print F.int (exact_reify $ big_test 2);;
#use "test-p.ml";;
timeit $ fun () -> print F.int (exact_reify $ big_test 2);;
timeit $ fun () -> print F.int (exact_reify $ big_test 3);;
timeit $ fun () -> print F.int (exact_reify $ big_test 1);;
#use "test-p.ml";;
timeit $ fun () -> print F.int (exact_reify $ big_test 1);;
timeit $ fun () -> print F.int (exact_reify $ big_test 2);;
get_samples 1 $ fun () -> music2_main [E;A;Gsharp;A] [B;A;B];;
timeit $ (fun () -> get_samples'' 1000 $ big_test 7);;
timeit $ (fun () -> get_samples'' 1 $ big_test 7);;
#use "test-p.ml";;
timeit $ (fun () -> get_samples'' 1 $ big_test 7);;
timeit $ (fun () -> get_samples'' 1 $ big_test 3);;
Inference.TreeSampler.flatten;;
Inference.TreeSampler.md_to_node;
Inference.TreeSampler.md_to_node;;
MDist.foldl;;
Prob.MDist.foldl;;
#use "test-p.ml";;
timeit $ (fun () -> get_samples'' 1 $ big_test 3);;
#use "test-p.ml";;
timeit $ (fun () -> get_samples'' 1 $ big_test 3);;
timeit $ (fun () -> get_samples'' 1 $ big_test 4);;
timeit $ (fun () -> get_samples'' 10 $ big_test 4);;
timeit $ (fun () -> get_samples'' 10 $ big_test 5);;
#use "test-p.ml";;
timeit $ (fun () -> get_samples'' 10 $ big_test 5);;
module I=Inference3;;
#use "test-p.ml";;
timeit $ (fun () -> get_samples'' 10 $ big_test 5);;
#use "test-p.ml";;
timeit $ (fun () -> get_samples'' 10 $ big_test 5);;
#use "test-p.ml";;
timeit $ (fun () -> get_samples'' 10 $ big_test 5);;
#use "test-p.ml";;
timeit $ (fun () -> get_samples'' 10 $ big_test 5);;
#use "test-p.ml";;
timeit $ (fun () -> get_samples'' 10 $ big_test 5);;
#use "test-p.ml";;
timeit $ (fun () -> get_samples'' 10 $ big_test 5);;
#use "perftest.ml";;
print note_list $ reify test_main;;
#use "perftest.ml";;
print note_list $ reify test_main;;
#use "perftest.ml";;
module L=List;;
List.split_at 3 [10;20;30;40;50];;
List.split_at 0 [10;20;30;40;50];;
List.split_at 5 [10;20;30;40;50];;
List.split_nth 3 [10;20;30;40;50];;
List.split_nth 0 [10;20;30;40;50];;
List.split_nth 9 [10;20;30;40;50];;
List.split_at 9 [10;20;30;40;50];;
#use "perftest.ml";;
print note_list $ reify test_main;;
print note_list $ reify main_simple
;;
print F.unit $ reify main_simple
;;
print (const "x") $ reify main_simple
;;
List.split_at;;
module L=List;;
module L=BatList;;
flush_output;;
flush_output_channel;;
#use "perftest.ml";;
open Monads;;
module SL = StateT (List) (struct type t = int end);;
module SL = StateT (ListM) (struct type t = int end);;
module L=ListM;;
L.return 1;;
SL.return 1;;
SL.return 1 1;;
SL.return 1 10;;
module MO=MonadOps(SL);;
open MO;;
open SL;;
return 1 >>= put;;
return 1 >>= put % 10;;
return 1 >>= put $ 10;;
open Utils;;
return 1 >>= put $ 10;;
return 10 >>= (fun x -> lift [2;3;4] >>= (fun y -> return (x*y)));;
return 10 >>= (fun x -> lift [2;3;4] >>= (fun y -> return (x*y))) 10;
;
return 10 >>= (fun x -> lift [2;3;4] >>= (fun y -> return (x*y))) 10;;
return 10 >>= (fun x -> lift [2;3;4] >>= (fun y -> return (x*y)));;
return 10 >>= (fun x -> lift [2;3;4] >>= (fun y -> return (x*y))) $ 10;;
get >>= (fun x -> lift [2;3;4] >>= (fun y -> return (x*y))) $ 10;;
get >>= (fun x -> lift [2;3;4] >>= (fun y -> put y >> return (x*y))) $ 10;;
uuuse
;;
;
#use "test-p.ml";;
print F.int exact_reify (fun () -> die ());;
print F.int exact_reify die;;
print F.int (exact_reify die);;
print F.int (exact_reify $ test_nest);;
print F.int (exact_reify $ reflect (reify test_nest));;
print F.int (exact_reify $ fun () -> reflect (reify test_nest));;
#use "test-p.ml";;
print F.int (exact_reify $ fun () -> reflect (reify test_nest));;
print int_list (reify $ fun () -> let r=roller () in List.map r [1;2;1]);;
print int_list (exact_reify $ fun () -> let r=roller () in List.map r [1;2;1]);;
#use "test-p.ml";;
print int_list (exact_reify $ fun () -> let r=roller () in List.map r [1;2;1]);;
print int_list (reify $ fun () -> let r=roller () in List.map r [1;2;1]);;
print int_list (exact_reify $ fun () -> let r=roller () in List.map r [1;2;1]);;
#use "test-p.ml";;
print int_list (exact_reify $ fun () -> let r=roller () in List.map r [1;2;1]);;
#use "test-p.ml";;
print int_list (exact_reify $ fun () -> let r=roller () in List.map r [1;2;1]);;
#use "test-p.ml";;
print int_list (exact_reify $ fun () -> let r=roller () in List.map r [1;2;1]);;
print int_list (exact_reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4;5;6]) in List.map r [1;2;1]);;
print int_list (reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4;5;6]) in List.map r [1;2;1]);;
print int_list (exact_reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4;5;6]) in List.map r [1;2;1]);;
#use "test-p.ml";;
print int_list (exact_reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4;5;6]) in List.map r [1;2;1]);;
print int_list (exact_reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4;5;6]) in [r 1;r 2;r 1]);;
#use "test-p.ml";;
print int_list (exact_reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4;5;6]) in [r 1;r 2;r 1]);;
print int_list (exact_reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4]) in [r 1;r 2;r 1]);;
#use "test-p.ml";;
print int_list (exact_reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4]) in map r [1;2;1]);;
print int_list (exact_reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4]) in List.map r [1;2;1]);;
(exact_reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4]) in List.map r [1;2;1]);;
exact_reify (fun () -> let r=memo (fun k -> uniform [1;2;3;4]) in List.map r [1;2;1]);;
open ProbM;;
exact_reify (fun () -> let r=memo (fun k -> uniform [1;2;3;4]) in List.map r [1;2;1]);;
exact_reify (fun () -> let r=memo (fun k -> uniformly [|1;2;3;4|]) in List.map r [1;2;1]);;
reify (fun () -> let r=memo (fun k -> uniformly [|1;2;3;4|]) in List.map r [1;2;1]);;
reify0 (fun () -> let r=memo (fun k -> uniformly [|1;2;3;4|]) in List.map r [1;2;1]);;
exact_reify (fun () -> let r=memo (fun k -> uniformly [|1;2;3;4|]) in List.map r [1;2;1]);;
#use "test-p.ml";;
exact_reify (fun () -> let r=memo (fun k -> uniformly [|1;2;3;4|]) in List.map r [1;2;1]);;
#use "test-p.ml";;
exact_reify (fun () -> let r=memo (fun k -> uniformly [|1;2;3;4|]) in List.map r [1;2;1]);;
exact_reify (fun () -> let r=memo (fun k -> uniform [1;2;3;4]) in map r [1;2;1]);;
#use "test-p.ml";;
print int_list (exact_reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4]) in List.map r [1;2;1]);;
print int_list (exact_reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4]) in map r [1;2;1]);;
print int_list (reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4]) in map r [1;2;1]);;
#use "test-p.ml";;
print int_list (reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4]) in map r [1;2;1]);;
print int_list (exact_reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4]) in map r [1;2;1]);;
#use "test-p.ml";;
print int_list (exact_reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4]) in map r [1;2;1]);;
print int_list (reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4]) in map r [1;2;1]);;
#use "test-p.ml";;
print int_list (reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4]) in map r [1;2;1]);;
print int_list (exact_reify $ fun () -> let r=memo (fun k -> uniform [1;2;3;4]) in map r [1;2;1]);;
#use "schenker.ml";;
module MP=AP1(StringParser);;
#use "schenker.ml";;
module MP=AP1(StringParser);;
open StringParser;;
open MP;;
parse (oct ()) "34";;
exact_reify (fun () -> parse (oct ()) "34");;
#use "schenker.ml";;
first_parse (oct ()) "34";;
#use "schenker.ml";;
first_parse oct "34";;
module MP=AP1(StringParser);;
open MP;;
open StringParser;;
first_parse oct "34";;
#use "schenker.ml";;
first_parse oct "34";;
#use "schenker.ml";;
first_parse oct "34";;
exact_reify (fun () -> parse (oct ()) "34");;
first_success (fun () -> parse (oct ()) "34");;
Inference.first_success (fun () -> parse (oct ()) "34");;
Inference.first_success (reify0 (fun () -> parse (oct ()) "34"));;
#use "schenker.ml";;
first_parse oct "34";;
#use "schenker.ml";;
first_parse oct "34";;
#use "schenker.ml";;
first_parse oct "34";;
first_parse oct "3";;
#use "schenker.ml";;
first_parse oct "3";;
first_parse oct "4";;
first_parse pitch "A4";;
first_parse pitch "A5";;
first_parse pitch "C5";;
first_parse pitch "C#5";;
first_parse pitch "Cb5";;
first_parse pitch "Bb5";;
#use "schenker.ml";;
first_parse pitch "Bb5";;
first_parse (list_sep (terminal ' ') digit) "234";;
first_parse (list_sep (terminal ' ') digit) "2 3 4";;
first_parse (list_sep (terminal ' ') pitch) "C2 B3 E#4";;
#use "schenker.ml";;
first_parse chord "[C2 B3 E#4]";;
first_parse chord "[C2 _B3 E#4]";;
#use "schenker.ml";;
decimal [1,2,3]
;;
decimal [1;2;3]
decimal [1;2;3;0]
;;
decimal [0;1;2;3;0];;
decimal [0;1;2];;
#use "schenker.ml";;
first_parse chord "12[C2 _B3 E#4]";;
#use "schenker.ml";;
first_parse seq "12[C2 _B3 E#4]";;
first_parse seq mozart284;;
List.map first_parse seq mozart284;;
#use "schenker.ml";;
List.map first_parse seq mozart284;;
first_parse seq mozart284;;
#use "schenker.ml";;
first_parse seq mozart284;;
#use "schenker.ml";;
first_parse seq mozart284;;
first_parse seq "12[C2 _B3 E#4]";;
first_parse seq "12[]";;
#use "schenker.ml";;
first_parse seq "12[]";;
first_parse seq mozart284;;
#use "schenker.ml";;
first_parse seq mozart284;;
#use "schenker.ml";;
first_parse seq mozart284;;
#use "schenker.ml";;
first_parse seq mozart284;;
#use "schenker.ml";;
first_parse seq mozart284;;
topline (first_parse seq mozart284);;
List.map (fun (dur,notes) -> dur) (first_parse seq mozart284);;
List.map (fun (dur,notes) -> notes) (first_parse seq mozart284);;
List.map (fun (dur,notes) -> List.nth notes 1) (first_parse seq mozart284);;
List.map (fun (dur,notes) -> (dur,List.nth notes 1)) (first_parse seq mozart284);;
#use "schenker.ml";;
topline (first_parse seq mozart284);;
List.fold_left;;
#use "schenker.ml";;
topline (first_parse seq mozart284);;
coalesce (topline (first_parse seq mozart284));;
topline (first_parse seq mozart284) |> coalesce;;
first_parse seq mozart284 |> topline |> coalesce;;
List.max;;
#use "schenker.ml";;
first_parse seq mozart284 |> topline |> coalesce;;
first_parse seq mozart284 
;;
first_parse seq mozart284 |> topline;;
first_parse seq mozart284 |> topline |> coalesce;;
first_parse seq mozart284 |> topline |> coalesce;;
#use "schenker.ml";;
first_parse seq mozart284 |> topline |> coalesce;;
#use "schenker.ml";;
first_parse seq mozart284 |> topline |> coalesce;;
#use "schenker.ml";;
module PP = MP2;;
#use "schenker.ml";;
open MP2;;
reify (fun () -> 42);;
reify (fun () -> 42) (0,"hello");;
parse (reify (fun () -> 42)) (0,"hello");;
parse (reify (fun () -> 42)) "hello";;
parse (reify (fun () -> terminal 'h'; 42)) "hello";;
parse (reify note) "C4";;
reify0 (fun () -> parse (reify note) "C4");;
first_parse (reify note) "C4");;
first_parse;;
first_parse (fun () -> reify note) "C4");;
first_parse (fun () -> reify note ()) "C4");;
first_parse (fun () -> reify note) "C4";;
first_parse (fun () -> reify note);;
first_parse (fun () -> reify note) "hello";;
first_parse (fun () -> reify note) "C4";;
first_parse (fun () -> reify pitch) "C4";;
first_parse (fun () -> reify digit) "4";;
first_parse (fun () -> reify digit) "45";;
first_parse (fun () -> reify integer) "45";;
reify0 (fun () -> parse (reify note) "C4");;
reify note;;
reify0 (fun () -> reify note);;
note;;
reify0 (fun () -> reify (note ()));;
parse (reify (fun () -> terminal 'h'; 42)) "hello";;
parse (reify (fun () -> integer ())) "455";;
parse (reify (fun () -> integer)) "455";;
reify0 (fun () ->parse (reify (fun () -> integer ())) "455");;
reify0 (fun () ->parse (reify (integer ())) "455");;
reify0 (fun () ->parse (reify integer)) "455");;
reify0 (fun () ->parse (reify integer) "455");;
reify0 (fun () ->parse (reify digit) "4");;
reify0 (fun () -> (reify digit));;
reify0 (fun () -> parse (reify digit) (0,"4"));;
reify0 (fun () -> parse (reify digit) "4");;
reify0 (fun () -> parse (reify digit));;
reify0 (fun () -> parse (reify digit) "4");;
exact_reify (fun () -> parse (reify digit) "4");;
exact_reify (fun () -> parse_all (reify digit) "4");;
exact_reify (fun () -> parse_all (reify integer) "4");;
#use "schenker.ml";;
exact_reify (fun () -> parse_all (reify integer) "4");;
exact_reify (fun () -> parse (reify digit) "4");;
exact_reify (fun () -> parse_all (reify digit) "4");;
exact_reify (fun () -> parse_all (reify digit) "45");;
exact_reify (fun () -> parse_all (reify integer) "45");;
exact_reify (fun () -> parse_all (reify (list digit)) "45");;
#use "schenker.ml";;
exact_reify (fun () -> parse_all (reify (list_of digit)) "45");;
exact_reify (fun () -> parse_all (reify (fun () -> [digit ()])) "45");;
exact_reify (fun () -> parse_all (reify (fun () -> [digit ()])) "4");;
exact_reify (fun () -> parse_all (reify (fun () -> [digit ();digit ()])) "4");;
exact_reify (fun () -> parse_all (reify (fun () -> [digit ();digit ()])) "45");;
String.length "34";;
#use "schenker.ml";;
exact_reify (fun () -> parse_all (reify (fun () -> [digit ();digit ()])) "45");;
exact_reify (fun () -> parse_all (reify (fun () -> [digit ()])) "4");;
exact_reify (fun () -> parse_all (reify integer) "45");;
first_success (reify0 (fun () -> parse_all (reify integer) "45"));;
Inference.first_success (reify0 (fun () -> parse_all (reify integer) "45"));;
first_parse (fun () -> reify integer) "45";;
reify integer;;
#use "schenker.ml";;
first_parse (reify' integer) "45";;
#use "schenker.ml";;
first_parse (reify' seq) "1[A4 C3 D5]";;
first_parse (reify' note) "A4";;
first_parse (reify' integer) "45";;
first_parse (reify' nominal) "A";;
first_parse (reify' pitch_class) "A";;
first_parse (reify' acc) "#";;
first_parse (reify' acc) "";;
#use "schenker.ml";;
first_parse (reify' acc) "";;
first_parse (reify' note) "A4";;
first_parse (reify' note) "A#4";;
first_parse (reify' seq) "1[A4 C3 D5]";;
first_parse (reify' note) "A#4";;
first_parse (reify' chord) "[A#4]";;
first_parse (reify' chord) "1[A#4]";;
first_parse (reify' chord) "1[A#4 D3]";;
first_parse (reify' seq) "1[A4 C3 D5]";;
first_parse (reify' chord) "1[A#4 D3]";;
first_parse (reify' seq) "1[A#4 D3]";;
first_parse (reify' seq) "1[A#4 D3] 2[D3]";;
first_parse (reify' seq) "1[A#4 C3]";;
first_parse (reify' seq) "1[A#4 C3 D5]";;
first_parse (reify' seq) "1[A#4 D5]";;
first_parse (reify' seq) "1[A#4 D5 C4]";;
#use "schenker.ml";;
first_parse (reify' seq) "1[A#4 D5 C4]";;
first_parse (reify' seq) mozart248;;
first_parse (reify' seq) mozart284;;
first_parse seq mozart284;;
first_parse MP2.seq mozart284;;
first_parse MP1.seq mozart284;;
first_parse MP.seq mozart284;;
first_parse (reify' seq) mozart284;;
first_parse MP.seq mozart284;;
first_parse (reify' seq) mozart284;;
timeit;;
timeit (fun () -> first_parse (reify' seq) mozart284);;
timeit (fun () -> first_parse MP.seq mozart284);;
timeit (fun () -> first_parse (reify' seq) mozart284);;
#use "schenker.ml";;
timeit (fun () -> first_parse (reify' MP2.seq) mozart284);;
timeit (fun () -> first_parse (reify' seq) mozart284);;
timeit (fun () -> first_parse (reify' MP2.seq) mozart284);;
#use "schenker.ml";;
timeit (fun () -> (reify' MG2.seq) mozart284);;
timeit (fun () -> run (reify' MG2.seq));;
#use "schenker.ml";;
timeit (fun () -> run (reify' MG2.seq));;
timeit (fun () -> CharGen.run (reify' MG2.seq));;
timeit (fun () -> CharGen.run (MG2.reify' MG2.seq));;
MG2.reify'
;;
MG2.reify' MG2.seq;;
MG2.reify' MG2.seq ();;
MG2.reify' MG2.seq;;
MG2.reify';;
MG2.run (MG2.reify' MG2.seq ());;
CharGen.run (MG2.reify' MG2.seq ());;
reify0 (fun () -> CharGen.run (MG2.reify' MG2.seq ()));;
reify0 (fun () -> snd (CharGen.run (MG2.reify' MG2.seq ())));;
rejection_sample (fun () -> CharGen.run (MG2.reify' MG2.seq ()));;
sample_rejection (fun () -> CharGen.run (MG2.reify' MG2.seq ()));;
sample_rejection (random_selector 10) (fun () -> CharGen.run (MG2.reify' MG2.seq ()));;
sample_rejection;;
sample_rejection (random_selector 10) 1 (fun () -> CharGen.run (MG2.reify' MG2.seq ()));;
String.of_list;;
sample_rejection (random_selector 10) 1 (fun () -> CharGen.run (MG2.reify' MG2.seq ()));;
sample_rejection (random_selector 10) 1 (fun () -> snd (CharGen.run (MG2.reify' MG2.seq ())));;
sample_rejection (random_selector 10) 1 (fun () -> CharGen.run (MG2.reify' MG2.seq ()) |> snd |> String.of_List));;
sample_rejection (random_selector 10) 1 (fun () -> CharGen.run (MG2.reify' MG2.seq ()) |> snd |> String.of_List)));;
sample_rejection (random_selector 10) 1 (fun () -> CharGen.run (MG2.reify' MG2.seq ()) |> snd |> String.of_List));;
sample_rejection (random_selector 10) 1 (fun () -> String.of_list (snd (CharGen.run (MG2.reify' MG2.seq ()))));;
sample_rejection (random_selector 10) 10 (fun () -> String.of_list (snd (CharGen.run (MG2.reify' MG2.seq ()))));;
sample_rejection (random_selector 20) 10 (fun () -> String.of_list (snd (CharGen.run (MG2.reify' MG2.seq ()))));;
#use "schenker.ml";;
sample_rejection (random_selector 20) 10 (fun () -> String.of_list (snd (CharGen.run (MG2.reify' MG2.seq ()))));;
#use "schenker.ml";;
sample_rejection (random_selector 20) 10 (fun () -> String.of_list (snd (CharGen.run (MG2.reify' MG2.seq ()))));;
CharGen.;;
CharGen;;
CharGen.run;;
module CharGen=RevListBuilder (TChar);;
CharGen.run;;
#use "schenker.ml";;
sample_rejection (random_selector 20) 10 (fun () -> String.of_list (snd (CharGen.run (MG2.reify' MG2.seq ()))));;
first_parse (reify' seq) mozart284;;
1.05 ^2;;
1.05 *. 2.0;;
1.05 ^ 2.0;;
1.05 ** 2.0;;
1.05 ^. 2.0;;
1.05 **. 2.0;;
generate;;
parse1;;
parse3;;
#use "grammar0.ml";;
#use "grammar.ml";;
complete;;
#use "grammar.ml";;
Parser.complete;;
#use "grammar.ml";;
module PC = Parser(TChar);;
#use "grammar.ml";;
module PC = Parser(TChar);;
module PC = Parser(TChar) with type t = char;;
module PC = Parser(TChar) with type t = char end;;
module PC = Parser(TChar)
;;
#use "grammar.ml";;
#use "schenker.ml:
";;
#use "schenker.ml";;
first_parse (reify' seq) mozart284;;
open MP2;;
first_parse (reify' seq) mozart284;;
MG2.run (MG2.reify' MG2.seq ());;
#use "schenker.ml";;
MG2.run;;
CharGen.run (MG2.reify' MG2.seq ());;
#use "grammar.ml";;
#use "schenker.ml";;
sample_rejection (random_selector 20) 10 (fun () -> String.of_list (snd (CharGen.run (MG2.reify' MG2.seq ()))));;
timeit (fun () -> first_parse (reify' MP2.seq) mozart284);;
timeit (fun () -> StringParser.first_parse (MP2.reify' MP2.seq) mozart284);;
timeit (fun () -> StringParser.first_parse (MP1.seq) mozart284);;
timeit (fun () -> StringParser.first_parse (MP1.seq) mozart284) |> topline;;
timeit (fun () -> StringParser.first_parse (MP1.seq) mozart284) |> topline |> coalesce;;
timeit (fun () -> StringParser.first_parse (MP2.reify' MP2.seq) mozart284) |> topline |> coalesce;;
StringParser.first_parse (MP2.reify' MP2.seq) mozart284
;;
StringParser.parse_all (MP2.reify' MP2.seq) mozart284
;;
StringParser.parse_all (MP2.reify MP2.seq) mozart284
;;
reify0 $ fun () -> StringParser.parse_all (MP2.reify MP2.seq) mozart284;;
Inference.first_success (reify0 $ fun () -> StringParser.parse_all (MP2.reify MP2.seq) mozart284);;
Inference.first_success (reify0 $ fun () -> StringParser.parse (MP2.reify MP2.seq) mozart284);;
Inference.first_success (reify0 $ fun () -> StringParser.parse_all (MP2.reify MP2.seq) mozart284);;
#use "schenker.ml";;
Inference.first_success (reify0 $ fun () -> StringParser.parse_all (MP2.reify MP2.seq) mozart284);;
Inference.first_success (reify0 $ fun () -> StringParser.parse_all (MP2.reify MP2.integer) "123");;
StringParser.first_parse (reify0 $ fun () -> StringParser.parse_all (MP2.reify MP2.integer) "123");;
StringParser.first_parse (MP2.reify' MP2.integer) "123";;
StringParser.first_parse (MP2.reify' MP2.integer) "123 35";;
#use "grammar.ml";;
#use "schenker.ml";;
StringParser.first_parse (MP2.reify' MP2.integer) "123 35";;
#use "grammar.ml";;
#use "schenker.ml";;
StringParser.first_parse (MP2.reify' MP2.integer) "123 35";;
#use "grammar.ml";;
#use "schenker.ml";;
StringParser.first_parse (MP2.reify' MP2.integer) "123 35";;
StringParser.first_parse (MP2.reify' MP2.note) "_B4";;
StringParser.first_parse (MP2.reify' MP2.note) "_B#4";;
StringParser.first_parse (MP2.reify' MP2.note) "_Bb4";;
StringParser.first_parse (MP2.reify' MP2.note) "Bb4";;
StringParser.first_parse (MP2.reify' MP2.pitch) "Bb4";;
StringParser.first_parse (MP2.reify' MP2.pitch) "B4";;
StringParser.first_parse (MP2.reify' MP2.pitch_class) "B4";;
StringParser.first_parse (MP2.reify' MP2.pitch_class) "B";;
StringParser.first_parse (MP2.reify' MP2.pitch_class) "B#";;
StringParser.first_parse (MP2.reify' MP2.pitch_class) "Bb";;
StringParser.first_parse (MP2.reify' MP2.pitch_class) "B##";;
StringParser.first_parse (MP2.reify' MP2.pitch_class) "Bbb";;
#use "schenker.ml";;
StringParser.first_parse (MP2.reify' MP2.pitch_class) "Bbb";;
StringParser.first_parse (MP2.reify' MP2.pitch_class) "Bb";;
StringParser.first_parse (MP2.reify' MP2.pitch_class) "B";;
StringParser.first_parse (MP2.reify' MP2.pitch_class) "B#";;
StringParser.first_parse (MP2.reify' MP2.pitch_class) "B##";;
StringParser.first_parse (MP2.reify' MP2.pitch_class) "B###";;
StringParser.parse_all (MP2.reify MP2.seq) mozart284
;;
StringParser.first_parse (MP2.reify' MP2.seq) mozart284
;;
timeit (fun () -> StringParser.first_parse (MP2.reify' MP2.seq) mozart284) |> topline |> coalesce;;
timeit (fun () -> StringParser.first_parse (MP1.seq) mozart284) |> topline |> coalesce;;
#use "schenker.ml";;
parse1 mozart284;;
parse2 mozart284;;
parse2 mozart284 = parse1 mozart284;;
Ca
;;
CharGen.run (MG2.reify' MG2.seq ());;
sample_rejection (random_selector 20) 10 (fun () -> String.of_list (snd (CharGen.run (MG2.reify' MG2.seq ()))));;
#use "schenker.ml";;
Random.int ();;
Random.int;;
Random.int 1000;;
#use "schenker.ml";;
gen1 10;;
gen2 10;;
#use "schenker.ml";;
gen2 10;;
#use "schenker.ml";;
gen2 10;;
#use "schenker.ml";;
#use "grammar.ml";;
#use "schenker.ml";;
#use "grammar.ml";;
#use "schenker.ml";;
#use "grammar.ml";;
#use "schenker.ml";;
gen2 10;;
gen1;;
gen1 10;;
parse2 mozart284 = parse1 mozart284;;
parse2 mozart284;;
#use "schenker.ml";;
parse2 mozart284;;
parse2 "1[A4] 1[B4]";;
parse2 "1[A4] 1[]";;
parse2 "1[A4] 1[B4]" |> topline;;
parse2 mozart284;;
#use "schenker.ml";;
parse2 "1[A4] 1[B4]" |> topline;;
parse2 "1[A4] 2[] 1[B4] " |> topline;;
parse2 "1[A4] 2[] 1[B4];;
;
;"
;;
parse2 "1[A4] 2[] 1[B4]";;
highest [];;
parse2 "1[A4] 2[] 1[B4]" |> topline;;
parse2 "1[A4] 2[] 1[B4]" |> topline |> coalesce;;
#use "schenker.ml";;
gen 10;;
#use "schenker.ml";;
gen 10;;
gen 1;;
#use "schenker.ml";;
gen 1;;
#use "schenker.ml";;
gen 1;;
parse2 "1[A4] 2[] 1[B4]" |> topline |> coalesce;;
parse2 mozart284;;
parse2 mozart284 |> topline;;
#use "schenker.ml";;
gen 1;;
parse2 mozart284;;
parse2 mozart284 |> topline;;
#use "schenker.ml";;
parse2 mozart284 |> topline;;
gen 1;;
#use "schenker.ml";;
#use "grammar.ml";;
#use "schenker.ml";;
parse2 mozart284 |> topline;;
gen 1;;
#use "schenker.ml";;
#use "grammar.ml";;
#use "schenker.ml";;
gen 1;;
gen 10;;
gen 100;;
#use "grammar.ml";;
#use "schenker.ml";;
gen 100;;
gen 10099;;
#use "schenker.ml";;
gen 100;;
SegGen.run;;
SegGen.run (SchP.reify; SchP.start ());;
SegGen.run (SchP.reify' SchP.start ());;
reify0 $ fun () -> SegGen.run (SchP.reify' SchP.start ());;
reify0 $ fun () -> SegGen.run (SchP.reify' (fun () ->terminal (1,Note (O,0))) ());;
reify0 $ fun () -> SegGen.run (SchP.reify' (fun () ->SchP.terminal (1,Note (O,0))) ());;
reify0 $ fun () -> SegGen.run (SchP.reify' (fun () ->12) ());;
reify0 $ fun () -> SegGen.run (SchP.reify' (fun () ->SchP.terminal (1,Note (O,0)); 12) ());;
gen1 19;;
reify0 $ fun () -> SegGen.run (SchP.reify' (fun () ->SchP.terminal (1,Note (O,0)); 12) ());;
reify0 $ fun () -> SegGen.run (SchP.reify' (fun () ->SchP.reflect (SegGen.terminal (1,Note (O,0)); 12) ());;
reify0 $ fun () -> SegGen.run (SchP.reify' (fun () ->SchP.reflect (SegGen.terminal (1,Note (O,0))); 12) ());;
#use "grammar.ml";;
#use "schenker.ml";;
reify0 $ fun () -> SegGen.run (SchP.reify' (fun () ->SchP.reflect (SegGen.terminal (1,Note (O,0))); 12) ());;
reify0 $ fun () -> SegGen.run (SchP.reify' (fun () ->SchP.reflect (SegGen.terminal (1,Note (O,0))); 22) ());;
reify0 $ fun () -> SegGen.run (SchP.reify' (fun () ->SchP.terminat (1,Note (O,0)); 22) ());;
reify0 $ fun () -> SegGen.run (SchP.reify' (fun () ->SchP.terminal (1,Note (O,0)); 22) ());;
reify0 $ fun () -> SegGen.run (SchP.reify' (fun () ->SchP.terminal (1,Note (O,0)); uniform_range 1 10) ());;
reify0 $ fun () -> SegGen.run (SchP.reify' (fun () -> uniform_range 1 10) ());;
exact_reify $ fun () -> SegGen.run (SchP.reify' (fun () -> uniform_range 1 10) ());;
#use "grammar.ml";;
#use "schenker.ml";;
gen1 19;;
gen 19;;
#use "schenker.ml";;
gen 19;;
#use "schenker.ml";;
gen;;
#use "schenker.ml";;
gen 1;;
gen;;
gen ();;
#use "schenker.ml";;
gen ();;
parse (gen ());;
let x = gen () in (x,parse x);;
parse [1, Note (O, 0)];;
parse [16, Note (O, 0)];;
parse [8, Note (O, 0); 8, Note (O, 0)];;
parse [8, Note (O, 0); 8, Note (O, 4)];;
parse [4, Note (O, 0); 12, Note (O, 4)];;
parse [4, Note (O, 0); 16, Note (O, 4)];;
#use "schenker.ml";;
parse [4, Note (O, 0); 12, Note (O, 4)];;
parse [2, Note (O, 0); 2, Note (O, 4)];;
parse [2, Note (O, 0); 2, Note (O, 5)];;
#use "schenker.ml";;
parse [2, Note (O, 0); 2, Note (O, 5)];;
#use "schenker.ml";;
parses [2, Note (O, 0); 2, Note (O, 5)];;
#use "schenker.ml";;
parses [2, Note (O, 0); 2, Note (O, 5)];;
#use "schenker.ml";;
parses 10 [2, Note (O, 0); 2, Note (O, 5)];;
parses 100 [2, Note (O, 0); 2, Note (O, 5)];;
parses 1000 [2, Note (O, 0); 2, Note (O, 5)];;
parses 5000 [2, Note (O, 0); 2, Note (O, 5)];;
parses 5000 [2, Note (O, 0); 1, Note (O, 5); 1, Note (O, 0)];;
parses 10000 [2, Note (O, 0); 1, Note (O, 5); 1, Note (O, 0)];;
parses 10000 [1, Note (O, 0); 1, Note (O,3); 1, Note (O, 5); 1, Note (O, 0)];;
#use "schenker.ml";;
