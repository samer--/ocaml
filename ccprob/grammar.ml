(* ----------- Probabilistic grammars - monadic approach --------- *)

open Utils
open Prob
open Monads
open Monadreps

(* interface required of grammar frameworks - it's monadic
 * where the special monadic operation is [terminal].
 * Monad is a specialisation of state monad, access
 * to state is not allowed. *)
module type GRAMMAR = sig
  type t
  type w
  include MONAD with type 'a m = w -> 'a * w
  val output : t -> unit m
  val input : t m
end

(* CFG parse tree - represents the result of parsing as either 
 * a terminal or a labelled grammar rule with a list of subtrees *)
type 'a ptree = Rule of string * 'a ptree list
              | Term of 'a

module Make (P : PROB) = struct
  module ProbOps = Prob.Ops (P)

  (* Given basic grammar operations (monad + terminal), these
   * useful things can be done *)
  module GrammarOps (G : GRAMMAR) = struct
    include MonadOps (G)
    include ProbOps
    include G

    (* gseq : string -> t ptree m list -> t ptree m *) 
    let gseq lab x : t ptree m = sequence x >>= fun l -> return (Rule (lab,l))

    (* gmap : ('a -> t ptree m) -> string -> 'a list -> t ptree m *) 
    let gmap f lab x : t ptree m = mapM f x >>= fun l -> return (Rule (lab,l))

    (* t : t -> t ptree m *)
    let t x = G.output x >> return (Term x)

    (* t_ : t -> unit m *)
    let t_ x = G.output x

    (* list_sep : 'b m -> 'a m thunk -> 'a list m *)
    let rec list_sep sep item = item () >>= fun x -> 
          if flip 0.5 then return [x]
          else sep >> list_sep sep item >>= fun xs -> return (x::xs) 

    (* list_of : 'a m thunk -> 'a list m *)
    let rec list_of item = item () >>= fun x -> 
          if flip 0.5 then return [x]
          else list_of item >>= fun xs -> return (x::xs) 

  end

  (* ------------- These are implementations of the GRAMMAR signature---------- *)

  (* State moand where state is a token list and terminal
   * eats tokens from the head - much like Prolog DCG in parse mode. *)
  module ListParser (Token : EQ) = struct
    include StateM(struct type t = Token.t list end)

    type t = Token.t
    type w = t list 

    let output (x : t) s1 = match s1 with
      | y::ys when Token.eq y x -> ((), ys)
      | _ -> P.fail ()

    let input s1 = match s1 with
      | y::ys -> (y, ys)
      | _ -> P.fail ()

    (* Parse takes a list of tokens, produces monadic result
     * plus any remaining unparsed tokens *)
    let parse (g : 'a m) input = g input

    (* parse_all is like parse but fails if there is any remaining input *)
    let parse_all g input =
      let (result,remaining) = parse g input in
      if remaining=[] then result else P.fail ()

    let complete ((t,r) : 'a * t list) = if r=[] then t else P.fail ()
  end

  (* nb could do with a lazy list parser here *)
  module LazyListParser (Token : TYPE) = struct
    module LList = LList (P)
    open LList

    include StateM(struct type t = Token.t llist end)

    type t = Token.t
    type w = t llist 

    let output (x : t) s1 = match s1 () with
      | LCons (h,t) when h () = x -> ((), t)
      | _ -> P.fail ()

    let input s1 = match s1 () with
      | LCons (h,t) -> (h (), t)
      | _ -> P.fail ()

    (* Parse takes a list of tokens, produces monadic result
     * plus any remaining unparsed tokens *)
    let parse (g : 'a m) input = g input

    (* parse_all is like parse but fails if there is any remaining input *)
    let parse_all g input =
      let (result,remaining) = parse g input in
      if is_nil remaining then result else P.fail ()

    let complete ((t,r) : 'a * t llist) = if is_nil r then t else P.fail ()
  end

  (* Monad is functional difference list, list of tokens
   * is generated by function composition *)
  module DLBuilder (Token : TYPE) = struct
    type 'a difflist = 'a list -> 'a list

    include StateM(struct type t = Token.t difflist end)
    type t = Token.t
    type w = t difflist  

    let output (x : t) s1 = ((), fun l -> s1 (cons x l))
    let input _ = failwith "GRAMMAR.input not supported by DLBuilder"
    let run (g : 'a m) = let (x,dl) = g id in (x,dl [])
  end

  (* Builds list in reverse using cons, then reverses
   * result when run *)
  module RevListBuilder (Token : TYPE) = struct
    include StateM(struct type t = Token.t list end)
    type t = Token.t
    type w = t list 

    let output (x : t) s1 = ((), cons x s1)
    let input _ = failwith "GRAMMAR.input not supported by RevListBuilder"
    let run (g : 'a m) = let (x,l) = g [] in (x,List.rev l)
  end

  module StringParser = struct
    include StateM (struct type t = int * string end)

    type t = char
    type w = int * string

    let output x (pos,str) = 
      if pos >= String.length str then P.fail ();
      if x = String.get str pos then ((),(succ pos,str))
      else P.fail ()

    let input (pos,str) = 
      if pos >= String.length str then P.fail ();
      (String.get str pos, (succ pos, str))

    let parse (g : 'a m) (input : string) = g (0,input)
    let parse_all g input =
      let (result,(pos,_)) = parse g input in
      if pos = String.length input then result else P.fail ()

  end

  module DirectGrammar (W : GRAMMAR) = struct
    module D = Direct (W)
    module P = ProbOps

    let output t = D.reflect (W.output t)
    let input () = D.reflect W.input
    let reify = D.reify
    let reify' f () = D.reify f
    let reflect = D.reflect

    let rec list_of item = let x = item () in 
      if P.flip 0.5 then [x] else x :: list_of item 

    let rec list_sep sep item = let x = item () in 
      if P.flip 0.5 then [x] else (sep (); x :: list_sep sep item)

    let rec pplus p item = item (); if P.flip p then 1 + pplus p item else 1 
    let rec pstar p item = if P.flip p then (item (); 1 + pstar p item) else 0 
    let rec plus item = pplus 0.5 item
    let rec star item = pstar 0.5 item
  end
end

(* This is a test grammar *)
(*
module G2 (W : GRAMMAR with type t = int) : sig
  type phrase = int ptree W.m
  val a : phrase
  val b : phrase
  val c : phrase
  val s : phrase
end= struct
  module GO = GrammarOps(W)
  open GO

  type phrase = int ptree W.m

  let rec b dl = gseq "B" (dist [ 0.2, [t 5]
                                ; 0.4, [t 5;  b]
                                ; 0.4, [t 4;  b]
                                ]) dl
  let c dl = gmap t "C" (dist [ 0.35, [0;0]; 0.35, [1;1]
                              ; 0.15, [0;1]; 0.15, [1;0]]) dl
  let d dl = gmap t "D" (dist [ 0.15, [0;0]; 0.15, [1;1]
                              ; 0.35, [0;1]; 0.35, [1;0]]) dl
  let a dl = gseq "A" (dist [0.5, [c;c;c]; 0.5, [d;d;d]]) dl
  let s = gseq "S" [a;b;a] 
end
*)
